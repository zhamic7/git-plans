(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push([typeof document === "object" ? document.currentScript : undefined, {

"[project]/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * @license React
 * react-jsx-dev-runtime.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
"production" !== ("TURBOPACK compile-time value", "development") && function() {
    function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch(type){
            case REACT_FRAGMENT_TYPE:
                return "Fragment";
            case REACT_PROFILER_TYPE:
                return "Profiler";
            case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
            case REACT_SUSPENSE_TYPE:
                return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            case REACT_ACTIVITY_TYPE:
                return "Activity";
        }
        if ("object" === typeof type) switch("number" === typeof type.tag && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof){
            case REACT_PORTAL_TYPE:
                return "Portal";
            case REACT_CONTEXT_TYPE:
                return (type.displayName || "Context") + ".Provider";
            case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
            case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                    return getComponentNameFromType(type(innerType));
                } catch (x) {}
        }
        return null;
    }
    function testStringCoercion(value) {
        return "" + value;
    }
    function checkKeyStringCoercion(value) {
        try {
            testStringCoercion(value);
            var JSCompiler_inline_result = !1;
        } catch (e) {
            JSCompiler_inline_result = !0;
        }
        if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            JSCompiler_temp_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0);
            return testStringCoercion(value);
        }
    }
    function getTaskName(type) {
        if (type === REACT_FRAGMENT_TYPE) return "<>";
        if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE) return "<...>";
        try {
            var name = getComponentNameFromType(type);
            return name ? "<" + name + ">" : "<...>";
        } catch (x) {
            return "<...>";
        }
    }
    function getOwner() {
        var dispatcher = ReactSharedInternals.A;
        return null === dispatcher ? null : dispatcher.getOwner();
    }
    function UnknownOwner() {
        return Error("react-stack-top-frame");
    }
    function hasValidKey(config) {
        if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) return !1;
        }
        return void 0 !== config.key;
    }
    function defineKeyPropWarningGetter(props, displayName) {
        function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = !0, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
        }
        warnAboutAccessingKey.isReactWarning = !0;
        Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: !0
        });
    }
    function elementRefGetterWithDeprecationWarning() {
        var componentName = getComponentNameFromType(this.type);
        didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = !0, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."));
        componentName = this.props.ref;
        return void 0 !== componentName ? componentName : null;
    }
    function ReactElement(type, key, self, source, owner, props, debugStack, debugTask) {
        self = props.ref;
        type = {
            $$typeof: REACT_ELEMENT_TYPE,
            type: type,
            key: key,
            props: props,
            _owner: owner
        };
        null !== (void 0 !== self ? self : null) ? Object.defineProperty(type, "ref", {
            enumerable: !1,
            get: elementRefGetterWithDeprecationWarning
        }) : Object.defineProperty(type, "ref", {
            enumerable: !1,
            value: null
        });
        type._store = {};
        Object.defineProperty(type._store, "validated", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: 0
        });
        Object.defineProperty(type, "_debugInfo", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: null
        });
        Object.defineProperty(type, "_debugStack", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: debugStack
        });
        Object.defineProperty(type, "_debugTask", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: debugTask
        });
        Object.freeze && (Object.freeze(type.props), Object.freeze(type));
        return type;
    }
    function jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self, debugStack, debugTask) {
        var children = config.children;
        if (void 0 !== children) if (isStaticChildren) if (isArrayImpl(children)) {
            for(isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)validateChildKeys(children[isStaticChildren]);
            Object.freeze && Object.freeze(children);
        } else console.error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
        else validateChildKeys(children);
        if (hasOwnProperty.call(config, "key")) {
            children = getComponentNameFromType(type);
            var keys = Object.keys(config).filter(function(k) {
                return "key" !== k;
            });
            isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
            didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error('A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />', isStaticChildren, children, keys, children), didWarnAboutKeySpread[children + isStaticChildren] = !0);
        }
        children = null;
        void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
        hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
        if ("key" in config) {
            maybeKey = {};
            for(var propName in config)"key" !== propName && (maybeKey[propName] = config[propName]);
        } else maybeKey = config;
        children && defineKeyPropWarningGetter(maybeKey, "function" === typeof type ? type.displayName || type.name || "Unknown" : type);
        return ReactElement(type, children, self, source, getOwner(), maybeKey, debugStack, debugTask);
    }
    function validateChildKeys(node) {
        "object" === typeof node && null !== node && node.$$typeof === REACT_ELEMENT_TYPE && node._store && (node._store.validated = 1);
    }
    var React = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    Symbol.for("react.provider");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, isArrayImpl = Array.isArray, createTask = console.createTask ? console.createTask : function() {
        return null;
    };
    React = {
        "react-stack-bottom-frame": function(callStackForError) {
            return callStackForError();
        }
    };
    var specialPropKeyWarningShown;
    var didWarnAboutElementRef = {};
    var unknownOwnerDebugStack = React["react-stack-bottom-frame"].bind(React, UnknownOwner)();
    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
    var didWarnAboutKeySpread = {};
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.jsxDEV = function(type, config, maybeKey, isStaticChildren, source, self) {
        var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
        return jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self, trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack, trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask);
    };
}();
}}),
"[project]/node_modules/next/dist/compiled/react/jsx-dev-runtime.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time falsy", 0) {
    "TURBOPACK unreachable";
} else {
    module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js [app-client] (ecmascript)");
}
}}),
"[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
(function() {
    var e = {
        675: function(e, r) {
            "use strict";
            r.byteLength = byteLength;
            r.toByteArray = toByteArray;
            r.fromByteArray = fromByteArray;
            var t = [];
            var f = [];
            var n = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
            var i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            for(var o = 0, u = i.length; o < u; ++o){
                t[o] = i[o];
                f[i.charCodeAt(o)] = o;
            }
            f["-".charCodeAt(0)] = 62;
            f["_".charCodeAt(0)] = 63;
            function getLens(e) {
                var r = e.length;
                if (r % 4 > 0) {
                    throw new Error("Invalid string. Length must be a multiple of 4");
                }
                var t = e.indexOf("=");
                if (t === -1) t = r;
                var f = t === r ? 0 : 4 - t % 4;
                return [
                    t,
                    f
                ];
            }
            function byteLength(e) {
                var r = getLens(e);
                var t = r[0];
                var f = r[1];
                return (t + f) * 3 / 4 - f;
            }
            function _byteLength(e, r, t) {
                return (r + t) * 3 / 4 - t;
            }
            function toByteArray(e) {
                var r;
                var t = getLens(e);
                var i = t[0];
                var o = t[1];
                var u = new n(_byteLength(e, i, o));
                var a = 0;
                var s = o > 0 ? i - 4 : i;
                var h;
                for(h = 0; h < s; h += 4){
                    r = f[e.charCodeAt(h)] << 18 | f[e.charCodeAt(h + 1)] << 12 | f[e.charCodeAt(h + 2)] << 6 | f[e.charCodeAt(h + 3)];
                    u[a++] = r >> 16 & 255;
                    u[a++] = r >> 8 & 255;
                    u[a++] = r & 255;
                }
                if (o === 2) {
                    r = f[e.charCodeAt(h)] << 2 | f[e.charCodeAt(h + 1)] >> 4;
                    u[a++] = r & 255;
                }
                if (o === 1) {
                    r = f[e.charCodeAt(h)] << 10 | f[e.charCodeAt(h + 1)] << 4 | f[e.charCodeAt(h + 2)] >> 2;
                    u[a++] = r >> 8 & 255;
                    u[a++] = r & 255;
                }
                return u;
            }
            function tripletToBase64(e) {
                return t[e >> 18 & 63] + t[e >> 12 & 63] + t[e >> 6 & 63] + t[e & 63];
            }
            function encodeChunk(e, r, t) {
                var f;
                var n = [];
                for(var i = r; i < t; i += 3){
                    f = (e[i] << 16 & 16711680) + (e[i + 1] << 8 & 65280) + (e[i + 2] & 255);
                    n.push(tripletToBase64(f));
                }
                return n.join("");
            }
            function fromByteArray(e) {
                var r;
                var f = e.length;
                var n = f % 3;
                var i = [];
                var o = 16383;
                for(var u = 0, a = f - n; u < a; u += o){
                    i.push(encodeChunk(e, u, u + o > a ? a : u + o));
                }
                if (n === 1) {
                    r = e[f - 1];
                    i.push(t[r >> 2] + t[r << 4 & 63] + "==");
                } else if (n === 2) {
                    r = (e[f - 2] << 8) + e[f - 1];
                    i.push(t[r >> 10] + t[r >> 4 & 63] + t[r << 2 & 63] + "=");
                }
                return i.join("");
            }
        },
        72: function(e, r, t) {
            "use strict";
            /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ var f = t(675);
            var n = t(783);
            var i = typeof Symbol === "function" && typeof Symbol.for === "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
            r.Buffer = Buffer;
            r.SlowBuffer = SlowBuffer;
            r.INSPECT_MAX_BYTES = 50;
            var o = 2147483647;
            r.kMaxLength = o;
            Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
            if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
                console.error("This browser lacks typed array (Uint8Array) support which is required by " + "`buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
            }
            function typedArraySupport() {
                try {
                    var e = new Uint8Array(1);
                    var r = {
                        foo: function() {
                            return 42;
                        }
                    };
                    Object.setPrototypeOf(r, Uint8Array.prototype);
                    Object.setPrototypeOf(e, r);
                    return e.foo() === 42;
                } catch (e) {
                    return false;
                }
            }
            Object.defineProperty(Buffer.prototype, "parent", {
                enumerable: true,
                get: function() {
                    if (!Buffer.isBuffer(this)) return undefined;
                    return this.buffer;
                }
            });
            Object.defineProperty(Buffer.prototype, "offset", {
                enumerable: true,
                get: function() {
                    if (!Buffer.isBuffer(this)) return undefined;
                    return this.byteOffset;
                }
            });
            function createBuffer(e) {
                if (e > o) {
                    throw new RangeError('The value "' + e + '" is invalid for option "size"');
                }
                var r = new Uint8Array(e);
                Object.setPrototypeOf(r, Buffer.prototype);
                return r;
            }
            function Buffer(e, r, t) {
                if (typeof e === "number") {
                    if (typeof r === "string") {
                        throw new TypeError('The "string" argument must be of type string. Received type number');
                    }
                    return allocUnsafe(e);
                }
                return from(e, r, t);
            }
            Buffer.poolSize = 8192;
            function from(e, r, t) {
                if (typeof e === "string") {
                    return fromString(e, r);
                }
                if (ArrayBuffer.isView(e)) {
                    return fromArrayLike(e);
                }
                if (e == null) {
                    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, " + "or Array-like Object. Received type " + typeof e);
                }
                if (isInstance(e, ArrayBuffer) || e && isInstance(e.buffer, ArrayBuffer)) {
                    return fromArrayBuffer(e, r, t);
                }
                if (typeof SharedArrayBuffer !== "undefined" && (isInstance(e, SharedArrayBuffer) || e && isInstance(e.buffer, SharedArrayBuffer))) {
                    return fromArrayBuffer(e, r, t);
                }
                if (typeof e === "number") {
                    throw new TypeError('The "value" argument must not be of type number. Received type number');
                }
                var f = e.valueOf && e.valueOf();
                if (f != null && f !== e) {
                    return Buffer.from(f, r, t);
                }
                var n = fromObject(e);
                if (n) return n;
                if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof e[Symbol.toPrimitive] === "function") {
                    return Buffer.from(e[Symbol.toPrimitive]("string"), r, t);
                }
                throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, " + "or Array-like Object. Received type " + typeof e);
            }
            Buffer.from = function(e, r, t) {
                return from(e, r, t);
            };
            Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
            Object.setPrototypeOf(Buffer, Uint8Array);
            function assertSize(e) {
                if (typeof e !== "number") {
                    throw new TypeError('"size" argument must be of type number');
                } else if (e < 0) {
                    throw new RangeError('The value "' + e + '" is invalid for option "size"');
                }
            }
            function alloc(e, r, t) {
                assertSize(e);
                if (e <= 0) {
                    return createBuffer(e);
                }
                if (r !== undefined) {
                    return typeof t === "string" ? createBuffer(e).fill(r, t) : createBuffer(e).fill(r);
                }
                return createBuffer(e);
            }
            Buffer.alloc = function(e, r, t) {
                return alloc(e, r, t);
            };
            function allocUnsafe(e) {
                assertSize(e);
                return createBuffer(e < 0 ? 0 : checked(e) | 0);
            }
            Buffer.allocUnsafe = function(e) {
                return allocUnsafe(e);
            };
            Buffer.allocUnsafeSlow = function(e) {
                return allocUnsafe(e);
            };
            function fromString(e, r) {
                if (typeof r !== "string" || r === "") {
                    r = "utf8";
                }
                if (!Buffer.isEncoding(r)) {
                    throw new TypeError("Unknown encoding: " + r);
                }
                var t = byteLength(e, r) | 0;
                var f = createBuffer(t);
                var n = f.write(e, r);
                if (n !== t) {
                    f = f.slice(0, n);
                }
                return f;
            }
            function fromArrayLike(e) {
                var r = e.length < 0 ? 0 : checked(e.length) | 0;
                var t = createBuffer(r);
                for(var f = 0; f < r; f += 1){
                    t[f] = e[f] & 255;
                }
                return t;
            }
            function fromArrayBuffer(e, r, t) {
                if (r < 0 || e.byteLength < r) {
                    throw new RangeError('"offset" is outside of buffer bounds');
                }
                if (e.byteLength < r + (t || 0)) {
                    throw new RangeError('"length" is outside of buffer bounds');
                }
                var f;
                if (r === undefined && t === undefined) {
                    f = new Uint8Array(e);
                } else if (t === undefined) {
                    f = new Uint8Array(e, r);
                } else {
                    f = new Uint8Array(e, r, t);
                }
                Object.setPrototypeOf(f, Buffer.prototype);
                return f;
            }
            function fromObject(e) {
                if (Buffer.isBuffer(e)) {
                    var r = checked(e.length) | 0;
                    var t = createBuffer(r);
                    if (t.length === 0) {
                        return t;
                    }
                    e.copy(t, 0, 0, r);
                    return t;
                }
                if (e.length !== undefined) {
                    if (typeof e.length !== "number" || numberIsNaN(e.length)) {
                        return createBuffer(0);
                    }
                    return fromArrayLike(e);
                }
                if (e.type === "Buffer" && Array.isArray(e.data)) {
                    return fromArrayLike(e.data);
                }
            }
            function checked(e) {
                if (e >= o) {
                    throw new RangeError("Attempt to allocate Buffer larger than maximum " + "size: 0x" + o.toString(16) + " bytes");
                }
                return e | 0;
            }
            function SlowBuffer(e) {
                if (+e != e) {
                    e = 0;
                }
                return Buffer.alloc(+e);
            }
            Buffer.isBuffer = function isBuffer(e) {
                return e != null && e._isBuffer === true && e !== Buffer.prototype;
            };
            Buffer.compare = function compare(e, r) {
                if (isInstance(e, Uint8Array)) e = Buffer.from(e, e.offset, e.byteLength);
                if (isInstance(r, Uint8Array)) r = Buffer.from(r, r.offset, r.byteLength);
                if (!Buffer.isBuffer(e) || !Buffer.isBuffer(r)) {
                    throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                }
                if (e === r) return 0;
                var t = e.length;
                var f = r.length;
                for(var n = 0, i = Math.min(t, f); n < i; ++n){
                    if (e[n] !== r[n]) {
                        t = e[n];
                        f = r[n];
                        break;
                    }
                }
                if (t < f) return -1;
                if (f < t) return 1;
                return 0;
            };
            Buffer.isEncoding = function isEncoding(e) {
                switch(String(e).toLowerCase()){
                    case "hex":
                    case "utf8":
                    case "utf-8":
                    case "ascii":
                    case "latin1":
                    case "binary":
                    case "base64":
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return true;
                    default:
                        return false;
                }
            };
            Buffer.concat = function concat(e, r) {
                if (!Array.isArray(e)) {
                    throw new TypeError('"list" argument must be an Array of Buffers');
                }
                if (e.length === 0) {
                    return Buffer.alloc(0);
                }
                var t;
                if (r === undefined) {
                    r = 0;
                    for(t = 0; t < e.length; ++t){
                        r += e[t].length;
                    }
                }
                var f = Buffer.allocUnsafe(r);
                var n = 0;
                for(t = 0; t < e.length; ++t){
                    var i = e[t];
                    if (isInstance(i, Uint8Array)) {
                        i = Buffer.from(i);
                    }
                    if (!Buffer.isBuffer(i)) {
                        throw new TypeError('"list" argument must be an Array of Buffers');
                    }
                    i.copy(f, n);
                    n += i.length;
                }
                return f;
            };
            function byteLength(e, r) {
                if (Buffer.isBuffer(e)) {
                    return e.length;
                }
                if (ArrayBuffer.isView(e) || isInstance(e, ArrayBuffer)) {
                    return e.byteLength;
                }
                if (typeof e !== "string") {
                    throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + "Received type " + typeof e);
                }
                var t = e.length;
                var f = arguments.length > 2 && arguments[2] === true;
                if (!f && t === 0) return 0;
                var n = false;
                for(;;){
                    switch(r){
                        case "ascii":
                        case "latin1":
                        case "binary":
                            return t;
                        case "utf8":
                        case "utf-8":
                            return utf8ToBytes(e).length;
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return t * 2;
                        case "hex":
                            return t >>> 1;
                        case "base64":
                            return base64ToBytes(e).length;
                        default:
                            if (n) {
                                return f ? -1 : utf8ToBytes(e).length;
                            }
                            r = ("" + r).toLowerCase();
                            n = true;
                    }
                }
            }
            Buffer.byteLength = byteLength;
            function slowToString(e, r, t) {
                var f = false;
                if (r === undefined || r < 0) {
                    r = 0;
                }
                if (r > this.length) {
                    return "";
                }
                if (t === undefined || t > this.length) {
                    t = this.length;
                }
                if (t <= 0) {
                    return "";
                }
                t >>>= 0;
                r >>>= 0;
                if (t <= r) {
                    return "";
                }
                if (!e) e = "utf8";
                while(true){
                    switch(e){
                        case "hex":
                            return hexSlice(this, r, t);
                        case "utf8":
                        case "utf-8":
                            return utf8Slice(this, r, t);
                        case "ascii":
                            return asciiSlice(this, r, t);
                        case "latin1":
                        case "binary":
                            return latin1Slice(this, r, t);
                        case "base64":
                            return base64Slice(this, r, t);
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return utf16leSlice(this, r, t);
                        default:
                            if (f) throw new TypeError("Unknown encoding: " + e);
                            e = (e + "").toLowerCase();
                            f = true;
                    }
                }
            }
            Buffer.prototype._isBuffer = true;
            function swap(e, r, t) {
                var f = e[r];
                e[r] = e[t];
                e[t] = f;
            }
            Buffer.prototype.swap16 = function swap16() {
                var e = this.length;
                if (e % 2 !== 0) {
                    throw new RangeError("Buffer size must be a multiple of 16-bits");
                }
                for(var r = 0; r < e; r += 2){
                    swap(this, r, r + 1);
                }
                return this;
            };
            Buffer.prototype.swap32 = function swap32() {
                var e = this.length;
                if (e % 4 !== 0) {
                    throw new RangeError("Buffer size must be a multiple of 32-bits");
                }
                for(var r = 0; r < e; r += 4){
                    swap(this, r, r + 3);
                    swap(this, r + 1, r + 2);
                }
                return this;
            };
            Buffer.prototype.swap64 = function swap64() {
                var e = this.length;
                if (e % 8 !== 0) {
                    throw new RangeError("Buffer size must be a multiple of 64-bits");
                }
                for(var r = 0; r < e; r += 8){
                    swap(this, r, r + 7);
                    swap(this, r + 1, r + 6);
                    swap(this, r + 2, r + 5);
                    swap(this, r + 3, r + 4);
                }
                return this;
            };
            Buffer.prototype.toString = function toString() {
                var e = this.length;
                if (e === 0) return "";
                if (arguments.length === 0) return utf8Slice(this, 0, e);
                return slowToString.apply(this, arguments);
            };
            Buffer.prototype.toLocaleString = Buffer.prototype.toString;
            Buffer.prototype.equals = function equals(e) {
                if (!Buffer.isBuffer(e)) throw new TypeError("Argument must be a Buffer");
                if (this === e) return true;
                return Buffer.compare(this, e) === 0;
            };
            Buffer.prototype.inspect = function inspect() {
                var e = "";
                var t = r.INSPECT_MAX_BYTES;
                e = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim();
                if (this.length > t) e += " ... ";
                return "<Buffer " + e + ">";
            };
            if (i) {
                Buffer.prototype[i] = Buffer.prototype.inspect;
            }
            Buffer.prototype.compare = function compare(e, r, t, f, n) {
                if (isInstance(e, Uint8Array)) {
                    e = Buffer.from(e, e.offset, e.byteLength);
                }
                if (!Buffer.isBuffer(e)) {
                    throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + "Received type " + typeof e);
                }
                if (r === undefined) {
                    r = 0;
                }
                if (t === undefined) {
                    t = e ? e.length : 0;
                }
                if (f === undefined) {
                    f = 0;
                }
                if (n === undefined) {
                    n = this.length;
                }
                if (r < 0 || t > e.length || f < 0 || n > this.length) {
                    throw new RangeError("out of range index");
                }
                if (f >= n && r >= t) {
                    return 0;
                }
                if (f >= n) {
                    return -1;
                }
                if (r >= t) {
                    return 1;
                }
                r >>>= 0;
                t >>>= 0;
                f >>>= 0;
                n >>>= 0;
                if (this === e) return 0;
                var i = n - f;
                var o = t - r;
                var u = Math.min(i, o);
                var a = this.slice(f, n);
                var s = e.slice(r, t);
                for(var h = 0; h < u; ++h){
                    if (a[h] !== s[h]) {
                        i = a[h];
                        o = s[h];
                        break;
                    }
                }
                if (i < o) return -1;
                if (o < i) return 1;
                return 0;
            };
            function bidirectionalIndexOf(e, r, t, f, n) {
                if (e.length === 0) return -1;
                if (typeof t === "string") {
                    f = t;
                    t = 0;
                } else if (t > 2147483647) {
                    t = 2147483647;
                } else if (t < -2147483648) {
                    t = -2147483648;
                }
                t = +t;
                if (numberIsNaN(t)) {
                    t = n ? 0 : e.length - 1;
                }
                if (t < 0) t = e.length + t;
                if (t >= e.length) {
                    if (n) return -1;
                    else t = e.length - 1;
                } else if (t < 0) {
                    if (n) t = 0;
                    else return -1;
                }
                if (typeof r === "string") {
                    r = Buffer.from(r, f);
                }
                if (Buffer.isBuffer(r)) {
                    if (r.length === 0) {
                        return -1;
                    }
                    return arrayIndexOf(e, r, t, f, n);
                } else if (typeof r === "number") {
                    r = r & 255;
                    if (typeof Uint8Array.prototype.indexOf === "function") {
                        if (n) {
                            return Uint8Array.prototype.indexOf.call(e, r, t);
                        } else {
                            return Uint8Array.prototype.lastIndexOf.call(e, r, t);
                        }
                    }
                    return arrayIndexOf(e, [
                        r
                    ], t, f, n);
                }
                throw new TypeError("val must be string, number or Buffer");
            }
            function arrayIndexOf(e, r, t, f, n) {
                var i = 1;
                var o = e.length;
                var u = r.length;
                if (f !== undefined) {
                    f = String(f).toLowerCase();
                    if (f === "ucs2" || f === "ucs-2" || f === "utf16le" || f === "utf-16le") {
                        if (e.length < 2 || r.length < 2) {
                            return -1;
                        }
                        i = 2;
                        o /= 2;
                        u /= 2;
                        t /= 2;
                    }
                }
                function read(e, r) {
                    if (i === 1) {
                        return e[r];
                    } else {
                        return e.readUInt16BE(r * i);
                    }
                }
                var a;
                if (n) {
                    var s = -1;
                    for(a = t; a < o; a++){
                        if (read(e, a) === read(r, s === -1 ? 0 : a - s)) {
                            if (s === -1) s = a;
                            if (a - s + 1 === u) return s * i;
                        } else {
                            if (s !== -1) a -= a - s;
                            s = -1;
                        }
                    }
                } else {
                    if (t + u > o) t = o - u;
                    for(a = t; a >= 0; a--){
                        var h = true;
                        for(var c = 0; c < u; c++){
                            if (read(e, a + c) !== read(r, c)) {
                                h = false;
                                break;
                            }
                        }
                        if (h) return a;
                    }
                }
                return -1;
            }
            Buffer.prototype.includes = function includes(e, r, t) {
                return this.indexOf(e, r, t) !== -1;
            };
            Buffer.prototype.indexOf = function indexOf(e, r, t) {
                return bidirectionalIndexOf(this, e, r, t, true);
            };
            Buffer.prototype.lastIndexOf = function lastIndexOf(e, r, t) {
                return bidirectionalIndexOf(this, e, r, t, false);
            };
            function hexWrite(e, r, t, f) {
                t = Number(t) || 0;
                var n = e.length - t;
                if (!f) {
                    f = n;
                } else {
                    f = Number(f);
                    if (f > n) {
                        f = n;
                    }
                }
                var i = r.length;
                if (f > i / 2) {
                    f = i / 2;
                }
                for(var o = 0; o < f; ++o){
                    var u = parseInt(r.substr(o * 2, 2), 16);
                    if (numberIsNaN(u)) return o;
                    e[t + o] = u;
                }
                return o;
            }
            function utf8Write(e, r, t, f) {
                return blitBuffer(utf8ToBytes(r, e.length - t), e, t, f);
            }
            function asciiWrite(e, r, t, f) {
                return blitBuffer(asciiToBytes(r), e, t, f);
            }
            function latin1Write(e, r, t, f) {
                return asciiWrite(e, r, t, f);
            }
            function base64Write(e, r, t, f) {
                return blitBuffer(base64ToBytes(r), e, t, f);
            }
            function ucs2Write(e, r, t, f) {
                return blitBuffer(utf16leToBytes(r, e.length - t), e, t, f);
            }
            Buffer.prototype.write = function write(e, r, t, f) {
                if (r === undefined) {
                    f = "utf8";
                    t = this.length;
                    r = 0;
                } else if (t === undefined && typeof r === "string") {
                    f = r;
                    t = this.length;
                    r = 0;
                } else if (isFinite(r)) {
                    r = r >>> 0;
                    if (isFinite(t)) {
                        t = t >>> 0;
                        if (f === undefined) f = "utf8";
                    } else {
                        f = t;
                        t = undefined;
                    }
                } else {
                    throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                }
                var n = this.length - r;
                if (t === undefined || t > n) t = n;
                if (e.length > 0 && (t < 0 || r < 0) || r > this.length) {
                    throw new RangeError("Attempt to write outside buffer bounds");
                }
                if (!f) f = "utf8";
                var i = false;
                for(;;){
                    switch(f){
                        case "hex":
                            return hexWrite(this, e, r, t);
                        case "utf8":
                        case "utf-8":
                            return utf8Write(this, e, r, t);
                        case "ascii":
                            return asciiWrite(this, e, r, t);
                        case "latin1":
                        case "binary":
                            return latin1Write(this, e, r, t);
                        case "base64":
                            return base64Write(this, e, r, t);
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return ucs2Write(this, e, r, t);
                        default:
                            if (i) throw new TypeError("Unknown encoding: " + f);
                            f = ("" + f).toLowerCase();
                            i = true;
                    }
                }
            };
            Buffer.prototype.toJSON = function toJSON() {
                return {
                    type: "Buffer",
                    data: Array.prototype.slice.call(this._arr || this, 0)
                };
            };
            function base64Slice(e, r, t) {
                if (r === 0 && t === e.length) {
                    return f.fromByteArray(e);
                } else {
                    return f.fromByteArray(e.slice(r, t));
                }
            }
            function utf8Slice(e, r, t) {
                t = Math.min(e.length, t);
                var f = [];
                var n = r;
                while(n < t){
                    var i = e[n];
                    var o = null;
                    var u = i > 239 ? 4 : i > 223 ? 3 : i > 191 ? 2 : 1;
                    if (n + u <= t) {
                        var a, s, h, c;
                        switch(u){
                            case 1:
                                if (i < 128) {
                                    o = i;
                                }
                                break;
                            case 2:
                                a = e[n + 1];
                                if ((a & 192) === 128) {
                                    c = (i & 31) << 6 | a & 63;
                                    if (c > 127) {
                                        o = c;
                                    }
                                }
                                break;
                            case 3:
                                a = e[n + 1];
                                s = e[n + 2];
                                if ((a & 192) === 128 && (s & 192) === 128) {
                                    c = (i & 15) << 12 | (a & 63) << 6 | s & 63;
                                    if (c > 2047 && (c < 55296 || c > 57343)) {
                                        o = c;
                                    }
                                }
                                break;
                            case 4:
                                a = e[n + 1];
                                s = e[n + 2];
                                h = e[n + 3];
                                if ((a & 192) === 128 && (s & 192) === 128 && (h & 192) === 128) {
                                    c = (i & 15) << 18 | (a & 63) << 12 | (s & 63) << 6 | h & 63;
                                    if (c > 65535 && c < 1114112) {
                                        o = c;
                                    }
                                }
                        }
                    }
                    if (o === null) {
                        o = 65533;
                        u = 1;
                    } else if (o > 65535) {
                        o -= 65536;
                        f.push(o >>> 10 & 1023 | 55296);
                        o = 56320 | o & 1023;
                    }
                    f.push(o);
                    n += u;
                }
                return decodeCodePointsArray(f);
            }
            var u = 4096;
            function decodeCodePointsArray(e) {
                var r = e.length;
                if (r <= u) {
                    return String.fromCharCode.apply(String, e);
                }
                var t = "";
                var f = 0;
                while(f < r){
                    t += String.fromCharCode.apply(String, e.slice(f, f += u));
                }
                return t;
            }
            function asciiSlice(e, r, t) {
                var f = "";
                t = Math.min(e.length, t);
                for(var n = r; n < t; ++n){
                    f += String.fromCharCode(e[n] & 127);
                }
                return f;
            }
            function latin1Slice(e, r, t) {
                var f = "";
                t = Math.min(e.length, t);
                for(var n = r; n < t; ++n){
                    f += String.fromCharCode(e[n]);
                }
                return f;
            }
            function hexSlice(e, r, t) {
                var f = e.length;
                if (!r || r < 0) r = 0;
                if (!t || t < 0 || t > f) t = f;
                var n = "";
                for(var i = r; i < t; ++i){
                    n += s[e[i]];
                }
                return n;
            }
            function utf16leSlice(e, r, t) {
                var f = e.slice(r, t);
                var n = "";
                for(var i = 0; i < f.length; i += 2){
                    n += String.fromCharCode(f[i] + f[i + 1] * 256);
                }
                return n;
            }
            Buffer.prototype.slice = function slice(e, r) {
                var t = this.length;
                e = ~~e;
                r = r === undefined ? t : ~~r;
                if (e < 0) {
                    e += t;
                    if (e < 0) e = 0;
                } else if (e > t) {
                    e = t;
                }
                if (r < 0) {
                    r += t;
                    if (r < 0) r = 0;
                } else if (r > t) {
                    r = t;
                }
                if (r < e) r = e;
                var f = this.subarray(e, r);
                Object.setPrototypeOf(f, Buffer.prototype);
                return f;
            };
            function checkOffset(e, r, t) {
                if (e % 1 !== 0 || e < 0) throw new RangeError("offset is not uint");
                if (e + r > t) throw new RangeError("Trying to access beyond buffer length");
            }
            Buffer.prototype.readUIntLE = function readUIntLE(e, r, t) {
                e = e >>> 0;
                r = r >>> 0;
                if (!t) checkOffset(e, r, this.length);
                var f = this[e];
                var n = 1;
                var i = 0;
                while(++i < r && (n *= 256)){
                    f += this[e + i] * n;
                }
                return f;
            };
            Buffer.prototype.readUIntBE = function readUIntBE(e, r, t) {
                e = e >>> 0;
                r = r >>> 0;
                if (!t) {
                    checkOffset(e, r, this.length);
                }
                var f = this[e + --r];
                var n = 1;
                while(r > 0 && (n *= 256)){
                    f += this[e + --r] * n;
                }
                return f;
            };
            Buffer.prototype.readUInt8 = function readUInt8(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 1, this.length);
                return this[e];
            };
            Buffer.prototype.readUInt16LE = function readUInt16LE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 2, this.length);
                return this[e] | this[e + 1] << 8;
            };
            Buffer.prototype.readUInt16BE = function readUInt16BE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 2, this.length);
                return this[e] << 8 | this[e + 1];
            };
            Buffer.prototype.readUInt32LE = function readUInt32LE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216;
            };
            Buffer.prototype.readUInt32BE = function readUInt32BE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);
            };
            Buffer.prototype.readIntLE = function readIntLE(e, r, t) {
                e = e >>> 0;
                r = r >>> 0;
                if (!t) checkOffset(e, r, this.length);
                var f = this[e];
                var n = 1;
                var i = 0;
                while(++i < r && (n *= 256)){
                    f += this[e + i] * n;
                }
                n *= 128;
                if (f >= n) f -= Math.pow(2, 8 * r);
                return f;
            };
            Buffer.prototype.readIntBE = function readIntBE(e, r, t) {
                e = e >>> 0;
                r = r >>> 0;
                if (!t) checkOffset(e, r, this.length);
                var f = r;
                var n = 1;
                var i = this[e + --f];
                while(f > 0 && (n *= 256)){
                    i += this[e + --f] * n;
                }
                n *= 128;
                if (i >= n) i -= Math.pow(2, 8 * r);
                return i;
            };
            Buffer.prototype.readInt8 = function readInt8(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 1, this.length);
                if (!(this[e] & 128)) return this[e];
                return (255 - this[e] + 1) * -1;
            };
            Buffer.prototype.readInt16LE = function readInt16LE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 2, this.length);
                var t = this[e] | this[e + 1] << 8;
                return t & 32768 ? t | 4294901760 : t;
            };
            Buffer.prototype.readInt16BE = function readInt16BE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 2, this.length);
                var t = this[e + 1] | this[e] << 8;
                return t & 32768 ? t | 4294901760 : t;
            };
            Buffer.prototype.readInt32LE = function readInt32LE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;
            };
            Buffer.prototype.readInt32BE = function readInt32BE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];
            };
            Buffer.prototype.readFloatLE = function readFloatLE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return n.read(this, e, true, 23, 4);
            };
            Buffer.prototype.readFloatBE = function readFloatBE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return n.read(this, e, false, 23, 4);
            };
            Buffer.prototype.readDoubleLE = function readDoubleLE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 8, this.length);
                return n.read(this, e, true, 52, 8);
            };
            Buffer.prototype.readDoubleBE = function readDoubleBE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 8, this.length);
                return n.read(this, e, false, 52, 8);
            };
            function checkInt(e, r, t, f, n, i) {
                if (!Buffer.isBuffer(e)) throw new TypeError('"buffer" argument must be a Buffer instance');
                if (r > n || r < i) throw new RangeError('"value" argument is out of bounds');
                if (t + f > e.length) throw new RangeError("Index out of range");
            }
            Buffer.prototype.writeUIntLE = function writeUIntLE(e, r, t, f) {
                e = +e;
                r = r >>> 0;
                t = t >>> 0;
                if (!f) {
                    var n = Math.pow(2, 8 * t) - 1;
                    checkInt(this, e, r, t, n, 0);
                }
                var i = 1;
                var o = 0;
                this[r] = e & 255;
                while(++o < t && (i *= 256)){
                    this[r + o] = e / i & 255;
                }
                return r + t;
            };
            Buffer.prototype.writeUIntBE = function writeUIntBE(e, r, t, f) {
                e = +e;
                r = r >>> 0;
                t = t >>> 0;
                if (!f) {
                    var n = Math.pow(2, 8 * t) - 1;
                    checkInt(this, e, r, t, n, 0);
                }
                var i = t - 1;
                var o = 1;
                this[r + i] = e & 255;
                while(--i >= 0 && (o *= 256)){
                    this[r + i] = e / o & 255;
                }
                return r + t;
            };
            Buffer.prototype.writeUInt8 = function writeUInt8(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 1, 255, 0);
                this[r] = e & 255;
                return r + 1;
            };
            Buffer.prototype.writeUInt16LE = function writeUInt16LE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 2, 65535, 0);
                this[r] = e & 255;
                this[r + 1] = e >>> 8;
                return r + 2;
            };
            Buffer.prototype.writeUInt16BE = function writeUInt16BE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 2, 65535, 0);
                this[r] = e >>> 8;
                this[r + 1] = e & 255;
                return r + 2;
            };
            Buffer.prototype.writeUInt32LE = function writeUInt32LE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 4, 4294967295, 0);
                this[r + 3] = e >>> 24;
                this[r + 2] = e >>> 16;
                this[r + 1] = e >>> 8;
                this[r] = e & 255;
                return r + 4;
            };
            Buffer.prototype.writeUInt32BE = function writeUInt32BE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 4, 4294967295, 0);
                this[r] = e >>> 24;
                this[r + 1] = e >>> 16;
                this[r + 2] = e >>> 8;
                this[r + 3] = e & 255;
                return r + 4;
            };
            Buffer.prototype.writeIntLE = function writeIntLE(e, r, t, f) {
                e = +e;
                r = r >>> 0;
                if (!f) {
                    var n = Math.pow(2, 8 * t - 1);
                    checkInt(this, e, r, t, n - 1, -n);
                }
                var i = 0;
                var o = 1;
                var u = 0;
                this[r] = e & 255;
                while(++i < t && (o *= 256)){
                    if (e < 0 && u === 0 && this[r + i - 1] !== 0) {
                        u = 1;
                    }
                    this[r + i] = (e / o >> 0) - u & 255;
                }
                return r + t;
            };
            Buffer.prototype.writeIntBE = function writeIntBE(e, r, t, f) {
                e = +e;
                r = r >>> 0;
                if (!f) {
                    var n = Math.pow(2, 8 * t - 1);
                    checkInt(this, e, r, t, n - 1, -n);
                }
                var i = t - 1;
                var o = 1;
                var u = 0;
                this[r + i] = e & 255;
                while(--i >= 0 && (o *= 256)){
                    if (e < 0 && u === 0 && this[r + i + 1] !== 0) {
                        u = 1;
                    }
                    this[r + i] = (e / o >> 0) - u & 255;
                }
                return r + t;
            };
            Buffer.prototype.writeInt8 = function writeInt8(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 1, 127, -128);
                if (e < 0) e = 255 + e + 1;
                this[r] = e & 255;
                return r + 1;
            };
            Buffer.prototype.writeInt16LE = function writeInt16LE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 2, 32767, -32768);
                this[r] = e & 255;
                this[r + 1] = e >>> 8;
                return r + 2;
            };
            Buffer.prototype.writeInt16BE = function writeInt16BE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 2, 32767, -32768);
                this[r] = e >>> 8;
                this[r + 1] = e & 255;
                return r + 2;
            };
            Buffer.prototype.writeInt32LE = function writeInt32LE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 4, 2147483647, -2147483648);
                this[r] = e & 255;
                this[r + 1] = e >>> 8;
                this[r + 2] = e >>> 16;
                this[r + 3] = e >>> 24;
                return r + 4;
            };
            Buffer.prototype.writeInt32BE = function writeInt32BE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 4, 2147483647, -2147483648);
                if (e < 0) e = 4294967295 + e + 1;
                this[r] = e >>> 24;
                this[r + 1] = e >>> 16;
                this[r + 2] = e >>> 8;
                this[r + 3] = e & 255;
                return r + 4;
            };
            function checkIEEE754(e, r, t, f, n, i) {
                if (t + f > e.length) throw new RangeError("Index out of range");
                if (t < 0) throw new RangeError("Index out of range");
            }
            function writeFloat(e, r, t, f, i) {
                r = +r;
                t = t >>> 0;
                if (!i) {
                    checkIEEE754(e, r, t, 4, 34028234663852886e22, -34028234663852886e22);
                }
                n.write(e, r, t, f, 23, 4);
                return t + 4;
            }
            Buffer.prototype.writeFloatLE = function writeFloatLE(e, r, t) {
                return writeFloat(this, e, r, true, t);
            };
            Buffer.prototype.writeFloatBE = function writeFloatBE(e, r, t) {
                return writeFloat(this, e, r, false, t);
            };
            function writeDouble(e, r, t, f, i) {
                r = +r;
                t = t >>> 0;
                if (!i) {
                    checkIEEE754(e, r, t, 8, 17976931348623157e292, -17976931348623157e292);
                }
                n.write(e, r, t, f, 52, 8);
                return t + 8;
            }
            Buffer.prototype.writeDoubleLE = function writeDoubleLE(e, r, t) {
                return writeDouble(this, e, r, true, t);
            };
            Buffer.prototype.writeDoubleBE = function writeDoubleBE(e, r, t) {
                return writeDouble(this, e, r, false, t);
            };
            Buffer.prototype.copy = function copy(e, r, t, f) {
                if (!Buffer.isBuffer(e)) throw new TypeError("argument should be a Buffer");
                if (!t) t = 0;
                if (!f && f !== 0) f = this.length;
                if (r >= e.length) r = e.length;
                if (!r) r = 0;
                if (f > 0 && f < t) f = t;
                if (f === t) return 0;
                if (e.length === 0 || this.length === 0) return 0;
                if (r < 0) {
                    throw new RangeError("targetStart out of bounds");
                }
                if (t < 0 || t >= this.length) throw new RangeError("Index out of range");
                if (f < 0) throw new RangeError("sourceEnd out of bounds");
                if (f > this.length) f = this.length;
                if (e.length - r < f - t) {
                    f = e.length - r + t;
                }
                var n = f - t;
                if (this === e && typeof Uint8Array.prototype.copyWithin === "function") {
                    this.copyWithin(r, t, f);
                } else if (this === e && t < r && r < f) {
                    for(var i = n - 1; i >= 0; --i){
                        e[i + r] = this[i + t];
                    }
                } else {
                    Uint8Array.prototype.set.call(e, this.subarray(t, f), r);
                }
                return n;
            };
            Buffer.prototype.fill = function fill(e, r, t, f) {
                if (typeof e === "string") {
                    if (typeof r === "string") {
                        f = r;
                        r = 0;
                        t = this.length;
                    } else if (typeof t === "string") {
                        f = t;
                        t = this.length;
                    }
                    if (f !== undefined && typeof f !== "string") {
                        throw new TypeError("encoding must be a string");
                    }
                    if (typeof f === "string" && !Buffer.isEncoding(f)) {
                        throw new TypeError("Unknown encoding: " + f);
                    }
                    if (e.length === 1) {
                        var n = e.charCodeAt(0);
                        if (f === "utf8" && n < 128 || f === "latin1") {
                            e = n;
                        }
                    }
                } else if (typeof e === "number") {
                    e = e & 255;
                } else if (typeof e === "boolean") {
                    e = Number(e);
                }
                if (r < 0 || this.length < r || this.length < t) {
                    throw new RangeError("Out of range index");
                }
                if (t <= r) {
                    return this;
                }
                r = r >>> 0;
                t = t === undefined ? this.length : t >>> 0;
                if (!e) e = 0;
                var i;
                if (typeof e === "number") {
                    for(i = r; i < t; ++i){
                        this[i] = e;
                    }
                } else {
                    var o = Buffer.isBuffer(e) ? e : Buffer.from(e, f);
                    var u = o.length;
                    if (u === 0) {
                        throw new TypeError('The value "' + e + '" is invalid for argument "value"');
                    }
                    for(i = 0; i < t - r; ++i){
                        this[i + r] = o[i % u];
                    }
                }
                return this;
            };
            var a = /[^+/0-9A-Za-z-_]/g;
            function base64clean(e) {
                e = e.split("=")[0];
                e = e.trim().replace(a, "");
                if (e.length < 2) return "";
                while(e.length % 4 !== 0){
                    e = e + "=";
                }
                return e;
            }
            function utf8ToBytes(e, r) {
                r = r || Infinity;
                var t;
                var f = e.length;
                var n = null;
                var i = [];
                for(var o = 0; o < f; ++o){
                    t = e.charCodeAt(o);
                    if (t > 55295 && t < 57344) {
                        if (!n) {
                            if (t > 56319) {
                                if ((r -= 3) > -1) i.push(239, 191, 189);
                                continue;
                            } else if (o + 1 === f) {
                                if ((r -= 3) > -1) i.push(239, 191, 189);
                                continue;
                            }
                            n = t;
                            continue;
                        }
                        if (t < 56320) {
                            if ((r -= 3) > -1) i.push(239, 191, 189);
                            n = t;
                            continue;
                        }
                        t = (n - 55296 << 10 | t - 56320) + 65536;
                    } else if (n) {
                        if ((r -= 3) > -1) i.push(239, 191, 189);
                    }
                    n = null;
                    if (t < 128) {
                        if ((r -= 1) < 0) break;
                        i.push(t);
                    } else if (t < 2048) {
                        if ((r -= 2) < 0) break;
                        i.push(t >> 6 | 192, t & 63 | 128);
                    } else if (t < 65536) {
                        if ((r -= 3) < 0) break;
                        i.push(t >> 12 | 224, t >> 6 & 63 | 128, t & 63 | 128);
                    } else if (t < 1114112) {
                        if ((r -= 4) < 0) break;
                        i.push(t >> 18 | 240, t >> 12 & 63 | 128, t >> 6 & 63 | 128, t & 63 | 128);
                    } else {
                        throw new Error("Invalid code point");
                    }
                }
                return i;
            }
            function asciiToBytes(e) {
                var r = [];
                for(var t = 0; t < e.length; ++t){
                    r.push(e.charCodeAt(t) & 255);
                }
                return r;
            }
            function utf16leToBytes(e, r) {
                var t, f, n;
                var i = [];
                for(var o = 0; o < e.length; ++o){
                    if ((r -= 2) < 0) break;
                    t = e.charCodeAt(o);
                    f = t >> 8;
                    n = t % 256;
                    i.push(n);
                    i.push(f);
                }
                return i;
            }
            function base64ToBytes(e) {
                return f.toByteArray(base64clean(e));
            }
            function blitBuffer(e, r, t, f) {
                for(var n = 0; n < f; ++n){
                    if (n + t >= r.length || n >= e.length) break;
                    r[n + t] = e[n];
                }
                return n;
            }
            function isInstance(e, r) {
                return e instanceof r || e != null && e.constructor != null && e.constructor.name != null && e.constructor.name === r.name;
            }
            function numberIsNaN(e) {
                return e !== e;
            }
            var s = function() {
                var e = "0123456789abcdef";
                var r = new Array(256);
                for(var t = 0; t < 16; ++t){
                    var f = t * 16;
                    for(var n = 0; n < 16; ++n){
                        r[f + n] = e[t] + e[n];
                    }
                }
                return r;
            }();
        },
        783: function(e, r) {
            /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ r.read = function(e, r, t, f, n) {
                var i, o;
                var u = n * 8 - f - 1;
                var a = (1 << u) - 1;
                var s = a >> 1;
                var h = -7;
                var c = t ? n - 1 : 0;
                var l = t ? -1 : 1;
                var p = e[r + c];
                c += l;
                i = p & (1 << -h) - 1;
                p >>= -h;
                h += u;
                for(; h > 0; i = i * 256 + e[r + c], c += l, h -= 8){}
                o = i & (1 << -h) - 1;
                i >>= -h;
                h += f;
                for(; h > 0; o = o * 256 + e[r + c], c += l, h -= 8){}
                if (i === 0) {
                    i = 1 - s;
                } else if (i === a) {
                    return o ? NaN : (p ? -1 : 1) * Infinity;
                } else {
                    o = o + Math.pow(2, f);
                    i = i - s;
                }
                return (p ? -1 : 1) * o * Math.pow(2, i - f);
            };
            r.write = function(e, r, t, f, n, i) {
                var o, u, a;
                var s = i * 8 - n - 1;
                var h = (1 << s) - 1;
                var c = h >> 1;
                var l = n === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
                var p = f ? 0 : i - 1;
                var y = f ? 1 : -1;
                var g = r < 0 || r === 0 && 1 / r < 0 ? 1 : 0;
                r = Math.abs(r);
                if (isNaN(r) || r === Infinity) {
                    u = isNaN(r) ? 1 : 0;
                    o = h;
                } else {
                    o = Math.floor(Math.log(r) / Math.LN2);
                    if (r * (a = Math.pow(2, -o)) < 1) {
                        o--;
                        a *= 2;
                    }
                    if (o + c >= 1) {
                        r += l / a;
                    } else {
                        r += l * Math.pow(2, 1 - c);
                    }
                    if (r * a >= 2) {
                        o++;
                        a /= 2;
                    }
                    if (o + c >= h) {
                        u = 0;
                        o = h;
                    } else if (o + c >= 1) {
                        u = (r * a - 1) * Math.pow(2, n);
                        o = o + c;
                    } else {
                        u = r * Math.pow(2, c - 1) * Math.pow(2, n);
                        o = 0;
                    }
                }
                for(; n >= 8; e[t + p] = u & 255, p += y, u /= 256, n -= 8){}
                o = o << n | u;
                s += n;
                for(; s > 0; e[t + p] = o & 255, p += y, o /= 256, s -= 8){}
                e[t + p - y] |= g * 128;
            };
        }
    };
    var r = {};
    function __nccwpck_require__(t) {
        var f = r[t];
        if (f !== undefined) {
            return f.exports;
        }
        var n = r[t] = {
            exports: {}
        };
        var i = true;
        try {
            e[t](n, n.exports, __nccwpck_require__);
            i = false;
        } finally{
            if (i) delete r[t];
        }
        return n.exports;
    }
    if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = __dirname + "/";
    var t = __nccwpck_require__(72);
    module.exports = t;
})();
}}),
"[project]/node_modules/quick-lru/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>QuickLRU)
});
class QuickLRU extends Map {
    #size = 0;
    #cache = new Map();
    #oldCache = new Map();
    #maxSize;
    #maxAge;
    #onEviction;
    constructor(options = {}){
        super();
        if (!(options.maxSize && options.maxSize > 0)) {
            throw new TypeError('`maxSize` must be a number greater than 0');
        }
        if (typeof options.maxAge === 'number' && options.maxAge === 0) {
            throw new TypeError('`maxAge` must be a number greater than 0');
        }
        this.#maxSize = options.maxSize;
        this.#maxAge = options.maxAge || Number.POSITIVE_INFINITY;
        this.#onEviction = options.onEviction;
    }
    // For tests.
    get __oldCache() {
        return this.#oldCache;
    }
    #emitEvictions(cache) {
        if (typeof this.#onEviction !== 'function') {
            return;
        }
        for (const [key, item] of cache){
            this.#onEviction(key, item.value);
        }
    }
    #deleteIfExpired(key, item) {
        if (typeof item.expiry === 'number' && item.expiry <= Date.now()) {
            if (typeof this.#onEviction === 'function') {
                this.#onEviction(key, item.value);
            }
            return this.delete(key);
        }
        return false;
    }
    #getOrDeleteIfExpired(key, item) {
        const deleted = this.#deleteIfExpired(key, item);
        if (deleted === false) {
            return item.value;
        }
    }
    #getItemValue(key, item) {
        return item.expiry ? this.#getOrDeleteIfExpired(key, item) : item.value;
    }
    #peek(key, cache) {
        const item = cache.get(key);
        return this.#getItemValue(key, item);
    }
    #set(key, value) {
        this.#cache.set(key, value);
        this.#size++;
        if (this.#size >= this.#maxSize) {
            this.#size = 0;
            this.#emitEvictions(this.#oldCache);
            this.#oldCache = this.#cache;
            this.#cache = new Map();
        }
    }
    #moveToRecent(key, item) {
        this.#oldCache.delete(key);
        this.#set(key, item);
    }
    *#entriesAscending() {
        for (const item of this.#oldCache){
            const [key, value] = item;
            if (!this.#cache.has(key)) {
                const deleted = this.#deleteIfExpired(key, value);
                if (deleted === false) {
                    yield item;
                }
            }
        }
        for (const item of this.#cache){
            const [key, value] = item;
            const deleted = this.#deleteIfExpired(key, value);
            if (deleted === false) {
                yield item;
            }
        }
    }
    get(key) {
        if (this.#cache.has(key)) {
            const item = this.#cache.get(key);
            return this.#getItemValue(key, item);
        }
        if (this.#oldCache.has(key)) {
            const item = this.#oldCache.get(key);
            if (this.#deleteIfExpired(key, item) === false) {
                this.#moveToRecent(key, item);
                return item.value;
            }
        }
    }
    set(key, value, { maxAge = this.#maxAge } = {}) {
        const expiry = typeof maxAge === 'number' && maxAge !== Number.POSITIVE_INFINITY ? Date.now() + maxAge : undefined;
        if (this.#cache.has(key)) {
            this.#cache.set(key, {
                value,
                expiry
            });
        } else {
            this.#set(key, {
                value,
                expiry
            });
        }
        return this;
    }
    has(key) {
        if (this.#cache.has(key)) {
            return !this.#deleteIfExpired(key, this.#cache.get(key));
        }
        if (this.#oldCache.has(key)) {
            return !this.#deleteIfExpired(key, this.#oldCache.get(key));
        }
        return false;
    }
    peek(key) {
        if (this.#cache.has(key)) {
            return this.#peek(key, this.#cache);
        }
        if (this.#oldCache.has(key)) {
            return this.#peek(key, this.#oldCache);
        }
    }
    delete(key) {
        const deleted = this.#cache.delete(key);
        if (deleted) {
            this.#size--;
        }
        return this.#oldCache.delete(key) || deleted;
    }
    clear() {
        this.#cache.clear();
        this.#oldCache.clear();
        this.#size = 0;
    }
    resize(newSize) {
        if (!(newSize && newSize > 0)) {
            throw new TypeError('`maxSize` must be a number greater than 0');
        }
        const items = [
            ...this.#entriesAscending()
        ];
        const removeCount = items.length - newSize;
        if (removeCount < 0) {
            this.#cache = new Map(items);
            this.#oldCache = new Map();
            this.#size = items.length;
        } else {
            if (removeCount > 0) {
                this.#emitEvictions(items.slice(0, removeCount));
            }
            this.#oldCache = new Map(items.slice(removeCount));
            this.#cache = new Map();
            this.#size = 0;
        }
        this.#maxSize = newSize;
    }
    *keys() {
        for (const [key] of this){
            yield key;
        }
    }
    *values() {
        for (const [, value] of this){
            yield value;
        }
    }
    *[Symbol.iterator]() {
        for (const item of this.#cache){
            const [key, value] = item;
            const deleted = this.#deleteIfExpired(key, value);
            if (deleted === false) {
                yield [
                    key,
                    value.value
                ];
            }
        }
        for (const item of this.#oldCache){
            const [key, value] = item;
            if (!this.#cache.has(key)) {
                const deleted = this.#deleteIfExpired(key, value);
                if (deleted === false) {
                    yield [
                        key,
                        value.value
                    ];
                }
            }
        }
    }
    *entriesDescending() {
        let items = [
            ...this.#cache
        ];
        for(let i = items.length - 1; i >= 0; --i){
            const item = items[i];
            const [key, value] = item;
            const deleted = this.#deleteIfExpired(key, value);
            if (deleted === false) {
                yield [
                    key,
                    value.value
                ];
            }
        }
        items = [
            ...this.#oldCache
        ];
        for(let i = items.length - 1; i >= 0; --i){
            const item = items[i];
            const [key, value] = item;
            if (!this.#cache.has(key)) {
                const deleted = this.#deleteIfExpired(key, value);
                if (deleted === false) {
                    yield [
                        key,
                        value.value
                    ];
                }
            }
        }
    }
    *entriesAscending() {
        for (const [key, value] of this.#entriesAscending()){
            yield [
                key,
                value.value
            ];
        }
    }
    get size() {
        if (!this.#size) {
            return this.#oldCache.size;
        }
        let oldCacheSize = 0;
        for (const key of this.#oldCache.keys()){
            if (!this.#cache.has(key)) {
                oldCacheSize++;
            }
        }
        return Math.min(this.#size + oldCacheSize, this.#maxSize);
    }
    get maxSize() {
        return this.#maxSize;
    }
    entries() {
        return this.entriesAscending();
    }
    forEach(callbackFunction, thisArgument = this) {
        for (const [key, value] of this.entriesAscending()){
            callbackFunction.call(thisArgument, value, key, this);
        }
    }
    get [Symbol.toStringTag]() {
        return 'QuickLRU';
    }
    toString() {
        return `QuickLRU(${this.size}/${this.maxSize})`;
    }
    [Symbol.for('nodejs.util.inspect.custom')]() {
        return this.toString();
    }
}
}}),
"[project]/node_modules/@maptiler/client/dist/maptiler-client.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "ClientConfig": (()=>ClientConfig),
    "ISOLanguage": (()=>ISOLanguage),
    "Language": (()=>Language),
    "MapStyle": (()=>MapStyle),
    "MapStyleVariant": (()=>MapStyleVariant),
    "NonISOLanguage": (()=>NonISOLanguage),
    "ReferenceMapStyle": (()=>ReferenceMapStyle),
    "ServiceError": (()=>ServiceError),
    "areSameLanguages": (()=>areSameLanguages),
    "bufferToPixelDataBrowser": (()=>bufferToPixelDataBrowser),
    "circumferenceAtLatitude": (()=>circumferenceAtLatitude),
    "config": (()=>config),
    "coordinates": (()=>coordinates),
    "data": (()=>data),
    "elevation": (()=>elevation),
    "expandMapStyle": (()=>expandMapStyle),
    "geocoding": (()=>geocoding),
    "geolocation": (()=>geolocation),
    "getAutoLanguage": (()=>getAutoLanguage),
    "getBufferToPixelDataParser": (()=>getBufferToPixelDataParser),
    "getLanguageInfoFromCode": (()=>getLanguageInfoFromCode),
    "getLanguageInfoFromFlag": (()=>getLanguageInfoFromFlag),
    "getLanguageInfoFromKey": (()=>getLanguageInfoFromKey),
    "getTileCache": (()=>getTileCache),
    "isLanguageInfo": (()=>isLanguageInfo),
    "mapStylePresetList": (()=>mapStylePresetList),
    "math": (()=>math),
    "misc": (()=>misc),
    "staticMaps": (()=>staticMaps),
    "styleToStyle": (()=>styleToStyle),
    "toLanguageInfo": (()=>toLanguageInfo)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$quick$2d$lru$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/quick-lru/index.js [app-client] (ecmascript)");
;
function tryGettingFetch() {
    if (typeof self !== "undefined") {
        return fetch.bind(self);
    }
    if (typeof global !== "undefined" && global.fetch) {
        return global.fetch;
    }
    return null;
}
class ClientConfig {
    constructor(){
        /**
     * MapTiler Cloud API key
     */ this._apiKey = "";
        /**
     * The fetch function. To be set if in Node < 18, otherwise
     * will be automatically resolved.
     */ this._fetch = tryGettingFetch();
        /**
     * Number of tiles to keep in cache
     */ this.tileCacheSize = 200;
    }
    /**
   * Set the MapTiler Cloud API key
   */ set apiKey(k) {
        this._apiKey = k;
    }
    /**
   * Get the MapTiler Cloud API key
   */ get apiKey() {
        return this._apiKey;
    }
    /**
   * Set a the custom fetch function to replace the default one
   */ set fetch(f) {
        this._fetch = f;
    }
    /**
   * Get the fetch fucntion
   */ get fetch() {
        return this._fetch;
    }
}
const config = new ClientConfig();
const NonISOLanguage = {
    /**
   * Language mode to display the labels in the end user's device language.
   */ AUTO: {
        code: null,
        flag: "auto",
        name: "Auto",
        latin: false,
        isMode: true,
        geocoding: true
    },
    /**
   * The OSM language using latin script. MapTiler discourages its use as a primary language setting due to the lack of actual linguistic specificity,
   * though it can be an handy fallback. This is not to be confused with the "Classical Latin" language, which is available under the tag `.CLASSICAL_LATIN`.
   */ LATIN: {
        code: "latin",
        flag: "name:latin",
        name: "Latin",
        latin: true,
        isMode: false,
        geocoding: false
    },
    /**
   * The OSM language using non-latin script. MapTiler discourages its use as a primary language setting due to the lack of actual linguistic specificity,
   * though it can be an handy fallback.
   */ NON_LATIN: {
        code: "nonlatin",
        flag: "name:nonlatin",
        name: "Non Latin",
        latin: false,
        isMode: false,
        geocoding: false
    },
    /**
   * Using the local language generaly (but not always) means that every labels of a given region will use the dominant local language.
   */ LOCAL: {
        code: null,
        flag: "name",
        name: "Local",
        latin: true,
        isMode: false,
        geocoding: false
    }
};
const ISOLanguage = {
    /**
   * Albanian language
   */ ALBANIAN: {
        code: "sq",
        flag: "name:sq",
        name: "Albanian",
        latin: true,
        isMode: false,
        geocoding: true
    },
    /**
   * Amharic language
   */ AMHARIC: {
        code: "am",
        flag: "name:am",
        name: "Amharic",
        latin: false,
        isMode: false,
        geocoding: true
    },
    /**
   * Arabic language (right-to-left script)
   */ ARABIC: {
        code: "ar",
        flag: "name:ar",
        name: "Arabic",
        latin: false,
        isMode: false,
        geocoding: true
    },
    /**
   * Armenian language
   */ ARMENIAN: {
        code: "hy",
        flag: "name:hy",
        name: "Armenian",
        latin: false,
        isMode: false,
        geocoding: true
    },
    /**
   * Azerbaijani language
   */ AZERBAIJANI: {
        code: "az",
        flag: "name:az",
        name: "Azerbaijani",
        latin: true,
        isMode: false,
        geocoding: true
    },
    /**
   * Basque language
   */ BASQUE: {
        code: "eu",
        flag: "name:eu",
        name: "Basque",
        latin: true,
        isMode: false,
        geocoding: true
    },
    /**
   * Belarusian langauge
   */ BELARUSIAN: {
        code: "be",
        flag: "name:be",
        name: "Belarusian",
        latin: false,
        isMode: false,
        geocoding: true
    },
    /**
   * Bengali language
   */ BENGALI: {
        code: "bn",
        flag: "name:bn",
        name: "Bengali",
        latin: true,
        isMode: false,
        geocoding: true
    },
    /**
   * Bosnian language
   */ BOSNIAN: {
        code: "bs",
        flag: "name:bs",
        name: "Bosnian",
        latin: true,
        isMode: false,
        geocoding: true
    },
    /**
   * Breton language
   */ BRETON: {
        code: "br",
        flag: "name:br",
        name: "Breton",
        latin: true,
        isMode: false,
        geocoding: true
    },
    /**
   * Bulgarian language
   */ BULGARIAN: {
        code: "bg",
        flag: "bg",
        name: "Bulgarian",
        latin: false,
        isMode: false,
        geocoding: true
    },
    /**
   * Catalan language
   */ CATALAN: {
        code: "ca",
        flag: "name:ca",
        name: "Catalan",
        latin: true,
        isMode: false,
        geocoding: true
    },
    /**
   * Chinese language
   */ CHINESE: {
        code: "zh",
        flag: "name:zh",
        name: "Chinese",
        latin: false,
        isMode: false,
        geocoding: true
    },
    /**
   * Traditional Chinese language
   */ TRADITIONAL_CHINESE: {
        code: "zh-Hant",
        flag: "name:zh-Hant",
        name: "Chinese (traditional)",
        latin: false,
        isMode: false,
        geocoding: false
    },
    /**
   * Simplified Chinese language
   */ SIMPLIFIED_CHINESE: {
        code: "zh-Hans",
        flag: "name:zh-Hans",
        name: "Chinese (simplified)",
        latin: false,
        isMode: false,
        geocoding: false
    },
    /**
   * Corsican language
   */ CORSICAN: {
        code: "co",
        flag: "name:co",
        name: "Corsican",
        latin: true,
        isMode: false,
        geocoding: true
    },
    /**
   * Croatian language
   */ CROATIAN: {
        code: "hr",
        flag: "name:hr",
        name: "Croatian",
        latin: true,
        isMode: false,
        geocoding: true
    },
    /**
   * Czech language
   */ CZECH: {
        code: "cs",
        flag: "name:cs",
        name: "Czech",
        latin: true,
        isMode: false,
        geocoding: true
    },
    /**
   * Danish language
   */ DANISH: {
        code: "da",
        flag: "name:da",
        name: "Danish",
        latin: true,
        isMode: false,
        geocoding: true
    },
    /**
   * Dutch language
   */ DUTCH: {
        code: "nl",
        flag: "name:nl",
        name: "Dutch",
        latin: true,
        isMode: false,
        geocoding: true
    },
    /**
   * German language
   */ GERMAN: {
        code: "de",
        flag: "name:de",
        name: "German",
        latin: true,
        isMode: false,
        geocoding: true
    },
    /**
   * Greek language
   */ GREEK: {
        code: "el",
        flag: "name:el",
        name: "Greek",
        latin: false,
        isMode: false,
        geocoding: true
    },
    /**
   * English language
   */ ENGLISH: {
        code: "en",
        flag: "name:en",
        name: "English",
        latin: true,
        isMode: false,
        geocoding: true
    },
    /**
   * Esperanto language
   */ ESPERANTO: {
        code: "eo",
        flag: "name:eo",
        name: "Esperanto",
        latin: true,
        isMode: false,
        geocoding: true
    },
    /**
   * Estonian language
   */ ESTONIAN: {
        code: "et",
        flag: "name:et",
        name: "Estonian",
        latin: true,
        isMode: false,
        geocoding: true
    },
    /**
   * Finnish language
   */ FINNISH: {
        code: "fi",
        flag: "name:fi",
        name: "Finnish",
        latin: true,
        isMode: false,
        geocoding: true
    },
    /**
   * French language
   */ FRENCH: {
        code: "fr",
        flag: "name:fr",
        name: "French",
        latin: true,
        isMode: false,
        geocoding: true
    },
    /**
   * Frisian language
   */ FRISIAN: {
        code: "fy",
        flag: "name:fy",
        name: "Frisian (West)",
        latin: true,
        isMode: false,
        geocoding: true
    },
    /**
   * Georgian language
   */ GEORGIAN: {
        code: "ka",
        flag: "name:ka",
        name: "Georgian",
        latin: false,
        isMode: false,
        geocoding: true
    },
    /**
   * Hebrew language (right-to-left non-latin script)
   */ HEBREW: {
        code: "he",
        flag: "name:he",
        name: "Hebrew",
        latin: false,
        isMode: false,
        geocoding: true
    },
    /**
   * Hindi language
   */ HINDI: {
        code: "hi",
        flag: "name:hi",
        name: "Hindi",
        latin: false,
        isMode: false,
        geocoding: true
    },
    /**
   * Hungarian language
   */ HUNGARIAN: {
        code: "hu",
        flag: "name:hu",
        name: "Hungarian",
        latin: true,
        isMode: false,
        geocoding: true
    },
    /**
   * Icelandic language
   */ ICELANDIC: {
        code: "is",
        flag: "name:is",
        name: "Icelandic",
        latin: true,
        isMode: false,
        geocoding: true
    },
    /**
   * Indonesian language
   */ INDONESIAN: {
        code: "id",
        flag: "name:id",
        name: "Indonesian",
        latin: true,
        isMode: false,
        geocoding: true
    },
    /**
   * Irish language
   */ IRISH: {
        code: "ga",
        flag: "name:ga",
        name: "Irish",
        latin: true,
        isMode: false,
        geocoding: true
    },
    /**
   * Italian language
   */ ITALIAN: {
        code: "it",
        flag: "name:it",
        name: "Italian",
        latin: true,
        isMode: false,
        geocoding: true
    },
    /**
   * Japanese language
   */ JAPANESE: {
        code: "ja",
        flag: "name:ja",
        name: "Japanese",
        latin: false,
        isMode: false,
        geocoding: true
    },
    /**
   * Japanese language in Hiragana form
   */ JAPANESE_HIRAGANA: {
        code: "ja-Hira",
        flag: "name:ja-Hira",
        name: "Japanese Hiragana form",
        latin: false,
        isMode: false,
        geocoding: false
    },
    /**
   * Japanese language (latin script)
   */ JAPANESE_2018: {
        code: "ja-Latn",
        flag: "name:ja-Latn",
        name: "Japanese (Latin 2018)",
        latin: true,
        isMode: false,
        geocoding: false
    },
    /**
   * Japanese language in Kana form (non-latin script)
   */ JAPANESE_KANA: {
        code: "ja_kana",
        flag: "name:ja_kana",
        name: "Japanese (Kana)",
        latin: false,
        isMode: false,
        geocoding: false
    },
    /**
   * Japanse language, romanized (latin script)
   */ JAPANESE_LATIN: {
        code: "ja_rm",
        flag: "name:ja_rm",
        name: "Japanese (Latin script)",
        latin: true,
        isMode: false,
        geocoding: false
    },
    /**
   * Kannada language
   */ KANNADA: {
        code: "kn",
        flag: "name:kn",
        name: "Kannada",
        latin: true,
        isMode: false,
        geocoding: true
    },
    /**
   * Kazakh language
   */ KAZAKH: {
        code: "kk",
        flag: "name:kk",
        name: "Kazakh",
        latin: false,
        isMode: false,
        geocoding: true
    },
    /**
   * Korean language
   */ KOREAN: {
        code: "ko",
        flag: "name:ko",
        name: "Korean",
        latin: false,
        isMode: false,
        geocoding: true
    },
    /**
   * Korean language (latin script)
   */ KOREAN_LATIN: {
        code: "ko-Latn",
        flag: "name:ko-Latn",
        name: "Korean (Latin script)",
        latin: true,
        isMode: false,
        geocoding: false
    },
    /**
   * Kurdish language
   */ KURDISH: {
        code: "ku",
        flag: "name:ku",
        name: "Kurdish",
        latin: true,
        isMode: false,
        geocoding: true
    },
    /**
   * Classical Latin language
   */ CLASSICAL_LATIN: {
        code: "la",
        flag: "name:la",
        name: "Latin",
        latin: true,
        isMode: false,
        geocoding: true
    },
    /**
   * Latvian language
   */ LATVIAN: {
        code: "lv",
        flag: "name:lv",
        name: "Latvian",
        latin: true,
        isMode: false,
        geocoding: true
    },
    /**
   * Lithuanian language
   */ LITHUANIAN: {
        code: "lt",
        flag: "name:lt",
        name: "Lithuanian",
        latin: true,
        isMode: false,
        geocoding: true
    },
    /**
   * Luxembourgish language
   */ LUXEMBOURGISH: {
        code: "lb",
        flag: "name:lb",
        name: "Luxembourgish",
        latin: true,
        isMode: false,
        geocoding: true
    },
    /**
   * Macedonian language
   */ MACEDONIAN: {
        code: "mk",
        flag: "name:mk",
        name: "Macedonian",
        latin: false,
        isMode: false,
        geocoding: true
    },
    /**
   * Malayalm language
   */ MALAYALAM: {
        code: "ml",
        flag: "name:ml",
        name: "Malayalam",
        latin: false,
        isMode: false,
        geocoding: true
    },
    /**
   * Maltese language
   */ MALTESE: {
        code: "mt",
        flag: "name:mt",
        name: "Maltese",
        latin: true,
        isMode: false,
        geocoding: true
    },
    /**
   * Norwegian language
   */ NORWEGIAN: {
        code: "no",
        flag: "name:no",
        name: "Norwegian",
        latin: true,
        isMode: false,
        geocoding: true
    },
    /**
   * Occitan language
   */ OCCITAN: {
        code: "oc",
        flag: "name:oc",
        name: "Occitan",
        latin: true,
        isMode: false,
        geocoding: true
    },
    /**
   * Persian language
   */ PERSIAN: {
        code: "fa",
        flag: "name:fa",
        name: "Persian",
        latin: false,
        isMode: false,
        geocoding: true
    },
    /**
   * Polish language
   */ POLISH: {
        code: "pl",
        flag: "name:pl",
        name: "Polish",
        latin: true,
        isMode: false,
        geocoding: true
    },
    /**
   * Portuguese language
   */ PORTUGUESE: {
        code: "pt",
        flag: "name:pt",
        name: "Portuguese",
        latin: true,
        isMode: false,
        geocoding: true
    },
    /**
   * Punjabi language
   */ PUNJABI: {
        code: "pa",
        flag: "name:pa",
        name: "Punjabi",
        latin: false,
        isMode: false,
        geocoding: true
    },
    /**
   * Western Punjabi language
   */ WESTERN_PUNJABI: {
        code: "pnb",
        flag: "name:pnb",
        name: "Western Punjabi",
        latin: false,
        isMode: false,
        geocoding: false
    },
    /**
   * Romanian language
   */ ROMANIAN: {
        code: "ro",
        flag: "name:ro",
        name: "Romanian",
        latin: true,
        isMode: false,
        geocoding: true
    },
    /**
   * Romansh language
   */ ROMANSH: {
        code: "rm",
        flag: "name:rm",
        name: "Romansh",
        latin: true,
        isMode: false,
        geocoding: true
    },
    /**
   * Russian language
   */ RUSSIAN: {
        code: "ru",
        flag: "name:ru",
        name: "Russian",
        latin: false,
        isMode: false,
        geocoding: true
    },
    /**
   * Serbian language (cyrillic script)
   */ SERBIAN_CYRILLIC: {
        code: "sr",
        flag: "name:sr",
        name: "Serbian (Cyrillic script)",
        latin: false,
        isMode: false,
        geocoding: true
    },
    /**
   * Serbian language (latin script)
   */ SERBIAN_LATIN: {
        code: "sr-Latn",
        flag: "name:sr-Latn",
        name: "Serbian (Latin script)",
        latin: true,
        isMode: false,
        geocoding: false
    },
    /**
   * Scottish Gaelic language
   */ SCOTTISH_GAELIC: {
        code: "gd",
        flag: "name:gd",
        name: "Scottish Gaelic",
        latin: true,
        isMode: false,
        geocoding: true
    },
    /**
   * Slovak language
   */ SLOVAK: {
        code: "sk",
        flag: "name:sk",
        name: "Slovak",
        latin: true,
        isMode: false,
        geocoding: true
    },
    /**
   * Slovene language
   */ SLOVENE: {
        code: "sl",
        flag: "name:sl",
        name: "Slovene",
        latin: true,
        isMode: false,
        geocoding: true
    },
    /**
   * Spanish language
   */ SPANISH: {
        code: "es",
        flag: "name:es",
        name: "Spanish",
        latin: true,
        isMode: false,
        geocoding: true
    },
    /**
   * Swedish language
   */ SWEDISH: {
        code: "sv",
        flag: "name:sv",
        name: "Swedish",
        latin: true,
        isMode: false,
        geocoding: true
    },
    /**
   * Tamil language
   */ TAMIL: {
        code: "ta",
        flag: "name:ta",
        name: "Tamil",
        latin: false,
        isMode: false,
        geocoding: true
    },
    /**
   * Telugu language
   */ TELUGU: {
        code: "te",
        flag: "name:te",
        name: "Telugu",
        latin: false,
        isMode: false,
        geocoding: true
    },
    /**
   * Thai language
   */ THAI: {
        code: "th",
        flag: "name:th",
        name: "Thai",
        latin: false,
        isMode: false,
        geocoding: true
    },
    /**
   * Turkish language
   */ TURKISH: {
        code: "tr",
        flag: "name:tr",
        name: "Turkish",
        latin: true,
        isMode: false,
        geocoding: true
    },
    /**
   * Ukrainian language
   */ UKRAINIAN: {
        code: "uk",
        flag: "name:uk",
        name: "Ukrainian",
        latin: false,
        isMode: false,
        geocoding: true
    },
    /**
   * Vietnamese language (latin script)
   */ VIETNAMESE: {
        code: "vi",
        flag: "name:vi",
        name: "Vietnamese (Latin script)",
        latin: true,
        isMode: false,
        geocoding: true
    },
    /**
   * Welsh language
   */ WELSH: {
        code: "cy",
        flag: "name:cy",
        name: "Welsh",
        latin: true,
        isMode: false,
        geocoding: true
    }
};
const Language = {
    ...NonISOLanguage,
    ...ISOLanguage
};
function getLanguageInfoFromKey(languageKey, languageDictionary = Language) {
    if (languageKey in languageDictionary) {
        return languageKey[languageKey];
    }
    return null;
}
function getLanguageInfoFromCode(languageCode, languageDictionary = Language) {
    for (const lang of Object.values(languageDictionary)){
        if (lang.code === languageCode) {
            return lang;
        }
    }
    return null;
}
function getLanguageInfoFromFlag(languageFlag, languageDictionary = Language) {
    for (const lang of Object.values(languageDictionary)){
        if (lang.flag === languageFlag) {
            return lang;
        }
    }
    return null;
}
function getAutoLanguage() {
    if (typeof navigator === "undefined") {
        const code = Intl.DateTimeFormat().resolvedOptions().locale.split("-")[0];
        const langInfo = getLanguageInfoFromCode(code);
        return langInfo ?? Language.ENGLISH;
    }
    const canditatelangs = Array.from(new Set(navigator.languages.map((l)=>l.split("-")[0]))).map((code)=>getLanguageInfoFromCode(code)).filter((li)=>li);
    return canditatelangs[0] ?? Language.ENGLISH;
}
function isLanguageInfo(obj) {
    return obj !== null && typeof obj === "object" && "code" in obj && "flag" in obj && "name" in obj && "latin" in obj && "isMode" in obj && "geocoding" in obj && (typeof obj.code === "string" || obj.code === null) && typeof obj.flag === "string" && typeof obj.name === "string" && typeof obj.latin === "boolean" && typeof obj.isMode === "boolean" && typeof obj.geocoding === "boolean";
}
function toLanguageInfo(lang, languageDictionary = Language) {
    if (isLanguageInfo(lang)) {
        return getLanguageInfoFromFlag(lang.flag, languageDictionary);
    }
    if (typeof lang !== "string") {
        return null;
    }
    return getLanguageInfoFromKey(lang, languageDictionary) || getLanguageInfoFromCode(lang, languageDictionary) || getLanguageInfoFromFlag(lang, languageDictionary) || null;
}
function areSameLanguages(langA, langB, languageDictionary = Language) {
    const langAObj = toLanguageInfo(langA, languageDictionary);
    const langBObj = toLanguageInfo(langB, languageDictionary);
    return langAObj && langBObj && langAObj.flag === langBObj.flag;
}
async function callFetch(resource, options = {}) {
    if (config.fetch === null) {
        throw new Error("The fetch function was not found. If on NodeJS < 18 please specify the fetch function with config.fetch");
    }
    if (new URL(resource).searchParams.get("key").trim() === "") {
        throw new Error("The MapTiler Cloud API key is missing. Set it in `config.apiKey` or get one for free at https://maptiler.com");
    }
    return config.fetch(resource, options);
}
const defaults = {
    maptilerApiURL: "https://api.maptiler.com/",
    mapStyle: "streets-v2"
};
Object.freeze(defaults);
class ServiceError extends Error {
    constructor(res, customMessage = ""){
        super(`Call to enpoint ${res.url} failed with the status code ${res.status}. ${customMessage}`);
        this.res = res;
    }
}
const customMessages$4 = {
    400: "Query too long / Invalid parameters",
    403: "Key is missing, invalid or restricted"
};
function addLanguageGeocodingOptions(searchParams, options) {
    const { language } = options;
    if (language === void 0) {
        return;
    }
    const languageCodes = (Array.isArray(language) ? language : [
        language
    ]).map((elem)=>toValidGeocodingLanguageCode(elem)).filter((elem)=>elem);
    const languages = Array.from(new Set(languageCodes)).join(",");
    searchParams.set("language", languages);
}
function toValidGeocodingLanguageCode(lang) {
    const langInfo = lang === Language.AUTO.flag ? getAutoLanguage() : typeof lang === "string" ? getLanguageInfoFromCode(lang) : isLanguageInfo(lang) ? lang.flag === Language.AUTO.flag ? getAutoLanguage() : getLanguageInfoFromFlag(lang.flag) : null;
    return langInfo?.geocoding ? langInfo.code : null;
}
function addCommonForwardAndReverseGeocodingOptions(searchParams, options) {
    const { apiKey, limit, types, excludeTypes } = options;
    searchParams.set("key", apiKey ?? config.apiKey);
    if (limit !== void 0) {
        searchParams.set("limit", String(limit));
    }
    if (types !== void 0) {
        searchParams.set("types", types.join(","));
    }
    if (excludeTypes !== void 0) {
        searchParams.set("excludeTypes", String(excludeTypes));
    }
    addLanguageGeocodingOptions(searchParams, options);
}
function addForwardGeocodingOptions(searchParams, options) {
    addCommonForwardAndReverseGeocodingOptions(searchParams, options);
    const { bbox, proximity, country, fuzzyMatch, autocomplete } = options;
    if (bbox !== void 0) {
        searchParams.set("bbox", bbox.join(","));
    }
    if (proximity !== void 0) {
        searchParams.set("proximity", proximity === "ip" ? proximity : proximity.join(","));
    }
    if (country !== void 0) {
        searchParams.set("country", country.join(","));
    }
    if (fuzzyMatch !== void 0) {
        searchParams.set("fuzzyMatch", fuzzyMatch ? "true" : "false");
    }
    if (autocomplete !== void 0) {
        searchParams.set("autocomplete", autocomplete ? "true" : "false");
    }
}
async function forward(query, options = {}) {
    if (typeof query !== "string" || query.trim().length === 0) {
        throw new Error("The query must be a non-empty string");
    }
    const endpoint = new URL(`geocoding/${encodeURIComponent(query)}.json`, defaults.maptilerApiURL);
    addForwardGeocodingOptions(endpoint.searchParams, options);
    const res = await callFetch(endpoint.toString());
    if (!res.ok) {
        throw new ServiceError(res, customMessages$4[res.status] ?? "");
    }
    return await res.json();
}
async function reverse(position, options = {}) {
    if (!Array.isArray(position) || position.length < 2) {
        throw new Error("The position must be an array of form [lng, lat].");
    }
    const endpoint = new URL(`geocoding/${position[0]},${position[1]}.json`, defaults.maptilerApiURL);
    addCommonForwardAndReverseGeocodingOptions(endpoint.searchParams, options);
    const res = await callFetch(endpoint.toString());
    if (!res.ok) {
        throw new ServiceError(res, customMessages$4[res.status] ?? "");
    }
    return await res.json();
}
async function byId(id, options = {}) {
    const endpoint = new URL(`geocoding/${id}.json`, defaults.maptilerApiURL);
    endpoint.searchParams.set("key", options.apiKey ?? config.apiKey);
    addLanguageGeocodingOptions(endpoint.searchParams, options);
    const res = await callFetch(endpoint.toString());
    if (!res.ok) {
        throw new ServiceError(res, customMessages$4[res.status] ?? "");
    }
    return await res.json();
}
async function batch$1(queries, options = {}) {
    if (!queries.length) {
        return [];
    }
    const joinedQuery = queries.map((query)=>encodeURIComponent(query)).join(";");
    const endpoint = new URL(`geocoding/${joinedQuery}.json`, defaults.maptilerApiURL);
    addForwardGeocodingOptions(endpoint.searchParams, options);
    const res = await callFetch(endpoint.toString());
    if (!res.ok) {
        throw new ServiceError(res, customMessages$4[res.status] ?? "");
    }
    const obj = await res.json();
    return queries.length === 1 ? [
        obj
    ] : obj;
}
const geocoding = {
    forward,
    reverse,
    byId,
    batch: batch$1
};
const customMessages$3 = {
    403: "Key is missing, invalid or restricted"
};
async function info(options = {}) {
    const endpoint = new URL(`geolocation/ip.json`, defaults.maptilerApiURL);
    endpoint.searchParams.set("key", options.apiKey ?? config.apiKey);
    const urlWithParams = endpoint.toString();
    const res = await callFetch(urlWithParams);
    if (!res.ok) {
        throw new ServiceError(res, res.status in customMessages$3 ? customMessages$3[res.status] : "");
    }
    const obj = await res.json();
    return obj;
}
const geolocation = {
    info
};
const customMessages$2 = {
    403: "Key is missing, invalid or restricted"
};
async function search(query, options = {}) {
    if (typeof query !== "string" || query.trim().length === 0) {
        throw new Error("The query must be a non-empty string");
    }
    const endpoint = new URL(`coordinates/search/${query}.json`, defaults.maptilerApiURL);
    endpoint.searchParams.set("key", options.apiKey ?? config.apiKey);
    if ("limit" in options) {
        endpoint.searchParams.set("limit", options.limit.toString());
    }
    if ("transformations" in options) {
        endpoint.searchParams.set("transformations", options.transformations.toString());
    }
    if ("exports" in options) {
        endpoint.searchParams.set("exports", options.exports.toString());
    }
    const urlWithParams = endpoint.toString();
    const res = await callFetch(urlWithParams);
    if (!res.ok) {
        throw new ServiceError(res, res.status in customMessages$2 ? customMessages$2[res.status] : "");
    }
    const obj = await res.json();
    return obj;
}
async function transform(positions, options = {}) {
    const coordinatesStr = (Array.isArray(positions[0]) ? positions : [
        positions
    ]).map((coord)=>`${coord[0]},${coord[1]}`).join(";");
    const endpoint = new URL(`coordinates/transform/${coordinatesStr}.json`, defaults.maptilerApiURL);
    endpoint.searchParams.set("key", options.apiKey ?? config.apiKey);
    if ("sourceCrs" in options) {
        endpoint.searchParams.set("s_srs", options.sourceCrs.toString());
    }
    if ("targetCrs" in options) {
        endpoint.searchParams.set("t_srs", options.targetCrs.toString());
    }
    if ("operations" in options) {
        endpoint.searchParams.set("ops", (Array.isArray(options.operations) ? options.operations : [
            options.operations
        ]).join("|"));
    }
    const urlWithParams = endpoint.toString();
    const res = await callFetch(urlWithParams);
    if (!res.ok) {
        throw new ServiceError(res, res.status in customMessages$2 ? customMessages$2[res.status] : "");
    }
    const obj = await res.json();
    return obj;
}
const coordinates = {
    search,
    transform
};
const customMessages$1 = {
    403: "Key is missing, invalid or restricted"
};
async function get(dataId, options = {}) {
    if (typeof dataId !== "string" || dataId.trim().length === 0) {
        throw new Error("The data ID must be a non-empty string");
    }
    const endpoint = new URL(`data/${encodeURIComponent(dataId)}/features.json`, defaults.maptilerApiURL);
    endpoint.searchParams.set("key", options.apiKey ?? config.apiKey);
    const urlWithParams = endpoint.toString();
    const res = await callFetch(urlWithParams);
    if (!res.ok) {
        throw new ServiceError(res, res.status in customMessages$1 ? customMessages$1[res.status] : "");
    }
    const obj = await res.json();
    return obj;
}
const data = {
    get
};
function expandMapStyle(style) {
    const maptilerDomainRegex = /^maptiler:\/\/(.*)/;
    let match;
    const trimmed = style.trim();
    let expandedStyle;
    if (trimmed.startsWith("http://") || trimmed.startsWith("https://")) {
        expandedStyle = trimmed;
    } else if ((match = maptilerDomainRegex.exec(trimmed)) !== null) {
        expandedStyle = `https://api.maptiler.com/maps/${match[1]}/style.json`;
    } else {
        expandedStyle = `https://api.maptiler.com/maps/${trimmed}/style.json`;
    }
    return expandedStyle;
}
class MapStyleVariant {
    constructor(name, variantType, id, referenceStyle, description, imageURL, deprecated = false){
        this.name = name;
        this.variantType = variantType;
        this.id = id;
        this.referenceStyle = referenceStyle;
        this.description = description;
        this.imageURL = imageURL;
        this.deprecated = deprecated;
    }
    /**
   * Get the human-friendly name
   * @returns
   */ getName() {
        return this.name;
    }
    getFullName() {
        return `${this.referenceStyle.getName()} ${this.name}`;
    }
    /**
   * Get the variant type (eg. "DEFAULT", "DARK", "PASTEL", etc.)
   * @returns
   */ getType() {
        return this.variantType;
    }
    /**
   * Get the MapTiler Cloud id
   * @returns
   */ getId() {
        return this.id;
    }
    /**
   * Get the human-friendly description
   */ getDescription() {
        return this.description;
    }
    /**
   * Get the reference style this variant belongs to
   * @returns
   */ getReferenceStyle() {
        return this.referenceStyle;
    }
    /**
   * Check if a variant of a given type exists for _this_ variants
   * (eg. if this is a "DARK", then we can check if there is a "LIGHT" variant of it)
   * @param variantType
   * @returns
   */ hasVariant(variantType) {
        return this.referenceStyle.hasVariant(variantType);
    }
    /**
   * Retrieve the variant of a given type. If not found, will return the "DEFAULT" variant.
   * (eg. _this_ "DARK" variant does not have any "PASTEL" variant, then the "DEFAULT" is returned)
   * @param variantType
   * @returns
   */ getVariant(variantType) {
        const variant = this.referenceStyle.getVariant(variantType);
        this.warnIfDeprecated(variant);
        return variant;
    }
    /**
   * Get all the variants for _this_ variants, except _this_ current one
   * @returns
   */ getVariants() {
        return this.referenceStyle.getVariants().filter((v)=>v !== this).map((v)=>{
            this.warnIfDeprecated(v);
            return v;
        });
    }
    /**
   * Get the image URL that represent _this_ variant
   * @returns
   */ getImageURL() {
        return this.imageURL;
    }
    /**
   * Get the style as usable by MapLibre, a string (URL) or a plain style description (StyleSpecification)
   * @returns
   */ getExpandedStyleURL() {
        return expandMapStyle(this.getId());
    }
    warnIfDeprecated(variant = this) {
        if (!variant.deprecated) return variant;
        const name = variant.getFullName();
        console.warn(`Style "${name}" is deprecated and will be removed in a future version.`);
        return variant;
    }
}
class ReferenceMapStyle {
    constructor(name, id){
        this.name = name;
        this.id = id;
        /**
     * Variants that belong to this reference style, key being the reference type
     */ this.variants = {};
        /**
     * Variants that belong to this reference style, ordered by relevance
     */ this.orderedVariants = [];
    }
    /**
   * Get the human-friendly name of this reference style
   * @returns
   */ getName() {
        return this.name;
    }
    /**
   * Get the id of _this_ reference style
   * @returns
   */ getId() {
        return this.id;
    }
    /**
   * Add a variant to _this_ reference style
   * @param v
   */ addVariant(v) {
        this.variants[v.getType()] = v;
        this.orderedVariants.push(v);
    }
    /**
   * Check if a given variant type exists for this reference style
   * @param variantType
   * @returns
   */ hasVariant(variantType) {
        return variantType in this.variants;
    }
    /**
   * Get a given variant. If the given type of variant does not exist for this reference style,
   * then the most relevant default variant is returned instead
   * @param variantType
   * @returns
   */ getVariant(variantType) {
        return variantType in this.variants ? this.variants[variantType] : this.orderedVariants[0];
    }
    /**
   * Get the list of variants for this reference style
   * @returns
   */ getVariants() {
        return Object.values(this.variants);
    }
    /**
   * Get the defualt variant for this reference style
   * @returns
   */ getDefaultVariant() {
        return this.orderedVariants[0].warnIfDeprecated();
    }
}
const mapStylePresetList = [
    {
        referenceStyleID: "STREETS",
        name: "Streets",
        description: "",
        variants: [
            {
                id: "streets-v2",
                name: "Default",
                variantType: "DEFAULT",
                description: "",
                imageURL: ""
            },
            {
                id: "streets-v2-dark",
                name: "Dark",
                variantType: "DARK",
                description: "",
                imageURL: ""
            },
            {
                id: "streets-v2-light",
                name: "Light",
                variantType: "LIGHT",
                description: "",
                imageURL: ""
            },
            {
                id: "streets-v2-night",
                name: "Night",
                variantType: "NIGHT",
                description: "",
                imageURL: ""
            },
            {
                id: "streets-v2-pastel",
                name: "Pastel",
                variantType: "PASTEL",
                description: "",
                imageURL: ""
            }
        ]
    },
    {
        referenceStyleID: "OUTDOOR",
        name: "Outdoor",
        description: "",
        variants: [
            {
                id: "outdoor-v2",
                name: "Default",
                variantType: "DEFAULT",
                description: "",
                imageURL: ""
            },
            {
                id: "outdoor-v2-dark",
                name: "Dark",
                variantType: "DARK",
                description: "",
                imageURL: ""
            }
        ]
    },
    {
        referenceStyleID: "WINTER",
        name: "Winter",
        description: "",
        variants: [
            {
                id: "winter-v2",
                name: "Default",
                variantType: "DEFAULT",
                description: "",
                imageURL: ""
            },
            {
                id: "winter-v2-dark",
                name: "Dark",
                variantType: "DARK",
                description: "",
                imageURL: ""
            }
        ]
    },
    {
        referenceStyleID: "SATELLITE",
        name: "Satellite",
        description: "",
        variants: [
            {
                id: "satellite",
                name: "Default",
                variantType: "DEFAULT",
                description: "",
                imageURL: ""
            }
        ]
    },
    {
        referenceStyleID: "HYBRID",
        name: "Hybrid",
        description: "",
        variants: [
            {
                id: "hybrid",
                deprecated: true,
                name: "Default",
                variantType: "DEFAULT",
                description: "",
                imageURL: ""
            }
        ]
    },
    {
        referenceStyleID: "BASIC",
        name: "Basic",
        description: "",
        variants: [
            {
                id: "basic-v2",
                name: "Default",
                variantType: "DEFAULT",
                description: "",
                imageURL: ""
            },
            {
                id: "basic-v2-dark",
                name: "Dark",
                variantType: "DARK",
                description: "",
                imageURL: ""
            },
            {
                id: "basic-v2-light",
                name: "Light",
                variantType: "LIGHT",
                description: "",
                imageURL: ""
            }
        ]
    },
    {
        referenceStyleID: "BRIGHT",
        name: "Bright",
        description: "",
        variants: [
            {
                id: "bright-v2",
                name: "Default",
                variantType: "DEFAULT",
                description: "",
                imageURL: ""
            },
            {
                id: "bright-v2-dark",
                name: "Dark",
                variantType: "DARK",
                description: "",
                imageURL: ""
            },
            {
                id: "bright-v2-light",
                name: "Light",
                variantType: "LIGHT",
                description: "",
                imageURL: ""
            },
            {
                id: "bright-v2-pastel",
                name: "Pastel",
                variantType: "PASTEL",
                description: "",
                imageURL: ""
            }
        ]
    },
    {
        referenceStyleID: "OPENSTREETMAP",
        name: "OpenStreetMap",
        description: "",
        variants: [
            {
                id: "openstreetmap",
                name: "Default",
                variantType: "DEFAULT",
                description: "",
                imageURL: ""
            }
        ]
    },
    {
        referenceStyleID: "TOPO",
        name: "Topo",
        description: "",
        variants: [
            {
                id: "topo-v2",
                name: "Default",
                variantType: "DEFAULT",
                description: "",
                imageURL: ""
            },
            {
                id: "topo-v2-dark",
                name: "Dark",
                variantType: "DARK",
                description: "",
                imageURL: ""
            },
            {
                id: "topo-v2-shiny",
                name: "Shiny",
                deprecated: true,
                variantType: "SHINY",
                description: "",
                imageURL: ""
            },
            {
                id: "topo-v2-pastel",
                name: "Pastel",
                variantType: "PASTEL",
                description: "",
                imageURL: ""
            },
            {
                id: "topo-v2-topographique",
                name: "Topographique",
                variantType: "TOPOGRAPHIQUE",
                description: "",
                imageURL: ""
            }
        ]
    },
    {
        referenceStyleID: "VOYAGER",
        name: "Voyager",
        description: "",
        variants: [
            {
                id: "voyager-v2",
                name: "Default",
                deprecated: true,
                variantType: "DEFAULT",
                description: "",
                imageURL: ""
            },
            {
                id: "voyager-v2-darkmatter",
                name: "Darkmatter",
                deprecated: true,
                variantType: "DARK",
                description: "",
                imageURL: ""
            },
            {
                id: "voyager-v2-positron",
                name: "Positron",
                deprecated: true,
                variantType: "LIGHT",
                description: "",
                imageURL: ""
            },
            {
                id: "voyager-v2-vintage",
                name: "Vintage",
                deprecated: true,
                variantType: "VINTAGE",
                description: "",
                imageURL: ""
            }
        ]
    },
    {
        referenceStyleID: "TONER",
        name: "Toner",
        description: "",
        variants: [
            {
                id: "toner-v2",
                name: "Default",
                variantType: "DEFAULT",
                description: "",
                imageURL: ""
            },
            {
                id: "toner-v2-background",
                name: "Background",
                variantType: "BACKGROUND",
                deprecated: true,
                description: "",
                imageURL: ""
            },
            {
                id: "toner-v2-lite",
                name: "Lite",
                variantType: "LITE",
                description: "",
                imageURL: ""
            },
            {
                id: "toner-v2-lines",
                name: "Lines",
                variantType: "LINES",
                deprecated: true,
                description: "",
                imageURL: ""
            }
        ]
    },
    {
        referenceStyleID: "DATAVIZ",
        name: "Dataviz",
        description: "",
        variants: [
            {
                id: "dataviz",
                name: "Default",
                variantType: "DEFAULT",
                description: "",
                imageURL: ""
            },
            {
                id: "dataviz-dark",
                name: "Dark",
                variantType: "DARK",
                description: "",
                imageURL: ""
            },
            {
                id: "dataviz-light",
                name: "Light",
                variantType: "LIGHT",
                description: "",
                imageURL: ""
            }
        ]
    },
    {
        referenceStyleID: "BACKDROP",
        name: "Backdrop",
        description: "",
        variants: [
            {
                id: "backdrop",
                name: "Default",
                variantType: "DEFAULT",
                description: "",
                imageURL: ""
            },
            {
                id: "backdrop-dark",
                name: "Dark",
                variantType: "DARK",
                description: "",
                imageURL: ""
            },
            {
                id: "backdrop-light",
                name: "Light",
                variantType: "LIGHT",
                description: "",
                imageURL: ""
            }
        ]
    },
    {
        referenceStyleID: "OCEAN",
        name: "Ocean",
        description: "",
        variants: [
            {
                id: "ocean",
                name: "Default",
                variantType: "DEFAULT",
                description: "",
                imageURL: ""
            }
        ]
    },
    {
        referenceStyleID: "AQUARELLE",
        name: "Aquarelle",
        description: "Watercolor map for creative use",
        variants: [
            {
                id: "aquarelle",
                name: "Default",
                variantType: "DEFAULT",
                description: "",
                imageURL: ""
            },
            {
                id: "aquarelle-dark",
                name: "Dark",
                variantType: "DARK",
                description: "",
                imageURL: ""
            },
            {
                id: "aquarelle-vivid",
                name: "Vivid",
                variantType: "VIVID",
                description: "",
                imageURL: ""
            }
        ]
    },
    {
        referenceStyleID: "LANDSCAPE",
        name: "Landscape",
        description: "Terrain map for data overlays and visualisations",
        variants: [
            {
                id: "landscape",
                name: "Default",
                variantType: "DEFAULT",
                description: "",
                imageURL: ""
            },
            {
                id: "landscape-dark",
                name: "Dark",
                variantType: "DARK",
                description: "",
                imageURL: ""
            },
            {
                id: "landscape-vivid",
                name: "Vivid",
                variantType: "VIVID",
                description: "",
                imageURL: ""
            }
        ]
    }
];
function makeReferenceStyleProxy(referenceStyle) {
    return new Proxy(referenceStyle, {
        get (target, prop, receiver) {
            if (target.hasVariant(prop)) {
                return target.getVariant(prop);
            }
            if (prop.toString().toUpperCase() === prop) {
                return referenceStyle.getDefaultVariant();
            }
            const style = Reflect.get(target, prop, receiver);
            return style;
        }
    });
}
function buildMapStyles() {
    const mapStyle = {};
    for(let i = 0; i < mapStylePresetList.length; i += 1){
        const refStyleInfo = mapStylePresetList[i];
        const refStyle = makeReferenceStyleProxy(new ReferenceMapStyle(refStyleInfo.name, refStyleInfo.referenceStyleID));
        for(let j = 0; j < refStyleInfo.variants.length; j += 1){
            const variantInfo = refStyleInfo.variants[j];
            const variant = new MapStyleVariant(variantInfo.name, // name
            variantInfo.variantType, // variantType
            variantInfo.id, // id
            refStyle, // referenceStyle
            variantInfo.description, variantInfo.imageURL, // imageURL
            variantInfo.deprecated);
            refStyle.addVariant(variant);
        }
        mapStyle[refStyleInfo.referenceStyleID] = refStyle;
    }
    return mapStyle;
}
function styleToStyle(style) {
    if (!style) {
        return MapStyle[mapStylePresetList[0].referenceStyleID].getDefaultVariant().getId();
    }
    if (typeof style === "string" || style instanceof String) {
        return style.trim().toLowerCase();
    }
    if (style instanceof MapStyleVariant) {
        return style.getId();
    }
    if (style instanceof ReferenceMapStyle) {
        return style.getDefaultVariant().getId();
    }
}
const MapStyle = buildMapStyles();
function extractLineStrings(geoJson) {
    const lineStrings = [];
    function extractFromGeometry(geometry) {
        if (geometry.type === "LineString" || geometry.type === "MultiLineString") {
            lineStrings.push(geometry);
        }
    }
    function extractFromFeature(feature) {
        if (feature.geometry) {
            extractFromGeometry(feature.geometry);
        }
    }
    function extractFromFeatureCollection(collection) {
        for (const feature of collection.features){
            if (feature.type === "Feature") {
                extractFromFeature(feature);
            } else if (feature.type === "FeatureCollection") {
                extractFromFeatureCollection(feature);
            }
        }
    }
    if (geoJson.type === "Feature") {
        extractFromFeature(geoJson);
    } else if (geoJson.type === "FeatureCollection") {
        extractFromFeatureCollection(geoJson);
    } else {
        extractFromGeometry(geoJson);
    }
    return lineStrings;
}
function getSqSegDist(p, p1, p2) {
    let x = p1[0], y = p1[1], dx = p2[0] - x, dy = p2[1] - y;
    if (dx !== 0 || dy !== 0) {
        const t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);
        if (t > 1) {
            x = p2[0];
            y = p2[1];
        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }
    dx = p[0] - x;
    dy = p[1] - y;
    return dx * dx + dy * dy;
}
function simplifyDPStep(points, first, last, sqTolerance, simplified) {
    let maxSqDist = sqTolerance, index;
    for(let i = first + 1; i < last; i++){
        const sqDist = getSqSegDist(points[i], points[first], points[last]);
        if (sqDist > maxSqDist) {
            index = i;
            maxSqDist = sqDist;
        }
    }
    if (maxSqDist > sqTolerance) {
        if (index - first > 1) {
            simplifyDPStep(points, first, index, sqTolerance, simplified);
        }
        simplified.push(points[index]);
        if (last - index > 1) {
            simplifyDPStep(points, index, last, sqTolerance, simplified);
        }
    }
}
function simplifyDouglasPeucker(points, sqTolerance) {
    const last = points.length - 1;
    const simplified = [
        points[0]
    ];
    simplifyDPStep(points, 0, last, sqTolerance, simplified);
    simplified.push(points[last]);
    return simplified;
}
function simplify(points, tolerance) {
    if (points.length <= 2) {
        return points;
    }
    const sqTolerance = tolerance !== void 0 ? tolerance * tolerance : 1;
    const simplePoints = simplifyDouglasPeucker(points, sqTolerance);
    return simplePoints;
}
const misc = {
    extractLineStrings,
    simplify
};
function staticMapMarkerToString(marker, includeColor = true) {
    let str = `${marker[0]},${marker[1]}`;
    if (marker.length === 3 && includeColor) {
        str += `,${marker[2]}`;
    }
    return str;
}
function simplifyAndStringify(path, maxNbChar = 3e3) {
    let str = path.map((point)=>point.join(",")).join("|");
    let tolerance = 5e-6;
    const toleranceStep = 1e-5;
    while(str.length > maxNbChar){
        const simplerPath = misc.simplify(path, tolerance);
        str = simplerPath.map((point)=>`${point[0]},${point[1]}`).join("|");
        tolerance += toleranceStep;
    }
    return str;
}
function centered(center, zoom, options = {}) {
    const style = styleToStyle(options.style);
    const scale = options.hiDPI ? "@2x" : "";
    const format = options.format ?? "png";
    let width = ~~(options.width ?? 1024);
    let height = ~~(options.height ?? 1024);
    if (options.hiDPI) {
        width = ~~(width / 2);
        height = ~~(height / 2);
    }
    const endpoint = new URL(`maps/${encodeURIComponent(style)}/static/${center[0]},${center[1]},${zoom}/${width}x${height}${scale}.${format}`, defaults.maptilerApiURL);
    if ("attribution" in options) {
        endpoint.searchParams.set("attribution", options.attribution.toString());
    }
    if ("markers" in options) {
        let markerStr = "";
        const hasIcon = "markerIcon" in options;
        if (hasIcon) {
            markerStr += `icon:${options.markerIcon}|`;
        }
        if (hasIcon && "markerAnchor" in options) {
            markerStr += `anchor:${options.markerAnchor}|`;
        }
        if (hasIcon && options.hiDPI) {
            markerStr += `scale:2|`;
        }
        const markerList = Array.isArray(options.markers[0]) ? options.markers : [
            options.markers
        ];
        markerStr += markerList.map((m)=>staticMapMarkerToString(m, !hasIcon)).join("|");
        endpoint.searchParams.set("markers", markerStr);
    }
    if ("path" in options) {
        let pathStr = "";
        pathStr += `fill:${options.pathFillColor ?? "none"}|`;
        if ("pathStrokeColor" in options) {
            pathStr += `stroke:${options.pathStrokeColor}|`;
        }
        if ("pathWidth" in options) {
            const pathWidth = options.pathWidth / (options.hiDPI ? 2 : 1);
            pathStr += `width:${pathWidth.toString()}|`;
        }
        pathStr += simplifyAndStringify(options.path);
        endpoint.searchParams.set("path", pathStr);
    }
    endpoint.searchParams.set("key", options.apiKey ?? config.apiKey);
    return endpoint.toString();
}
function bounded(boundingBox, options = {}) {
    const style = styleToStyle(options.style);
    const scale = options.hiDPI ? "@2x" : "";
    const format = options.format ?? "png";
    let width = ~~(options.width ?? 1024);
    let height = ~~(options.height ?? 1024);
    if (options.hiDPI) {
        width = ~~(width / 2);
        height = ~~(height / 2);
    }
    const endpoint = new URL(`maps/${encodeURIComponent(style)}/static/${boundingBox[0]},${boundingBox[1]},${boundingBox[2]},${boundingBox[3]}/${width}x${height}${scale}.${format}`, defaults.maptilerApiURL);
    if ("attribution" in options) {
        endpoint.searchParams.set("attribution", options.attribution.toString());
    }
    if ("padding" in options) {
        endpoint.searchParams.set("padding", options.padding.toString());
    }
    if ("markers" in options) {
        let markerStr = "";
        const hasIcon = "markerIcon" in options;
        if (hasIcon) {
            markerStr += `icon:${options.markerIcon}|`;
        }
        if (hasIcon && "markerAnchor" in options) {
            markerStr += `anchor:${options.markerAnchor}|`;
        }
        if (hasIcon && options.hiDPI) {
            markerStr += `scale:2|`;
        }
        const markerList = Array.isArray(options.markers[0]) ? options.markers : [
            options.markers
        ];
        markerStr += markerList.map((m)=>staticMapMarkerToString(m, !hasIcon)).join("|");
        endpoint.searchParams.set("markers", markerStr);
    }
    if ("path" in options) {
        let pathStr = "";
        pathStr += `fill:${options.pathFillColor ?? "none"}|`;
        if ("pathStrokeColor" in options) {
            pathStr += `stroke:${options.pathStrokeColor}|`;
        }
        if ("pathWidth" in options) {
            const pathWidth = options.pathWidth / (options.hiDPI ? 2 : 1);
            pathStr += `width:${pathWidth.toString()}|`;
        }
        pathStr += simplifyAndStringify(options.path);
        endpoint.searchParams.set("path", pathStr);
    }
    endpoint.searchParams.set("key", options.apiKey ?? config.apiKey);
    return endpoint.toString();
}
function automatic(options = {}) {
    if (!("markers" in options) && !("path" in options)) {
        throw new Error("Automatic static maps require markers and/or path to be created.");
    }
    const style = styleToStyle(options.style);
    const scale = options.hiDPI ? "@2x" : "";
    const format = options.format ?? "png";
    let width = ~~(options.width ?? 1024);
    let height = ~~(options.height ?? 1024);
    if (options.hiDPI) {
        width = ~~(width / 2);
        height = ~~(height / 2);
    }
    const endpoint = new URL(`maps/${encodeURIComponent(style)}/static/auto/${width}x${height}${scale}.${format}`, defaults.maptilerApiURL);
    if ("attribution" in options) {
        endpoint.searchParams.set("attribution", options.attribution.toString());
    }
    if ("padding" in options) {
        endpoint.searchParams.set("padding", options.padding.toString());
    }
    if ("markers" in options) {
        let markerStr = "";
        const hasIcon = "markerIcon" in options;
        if (hasIcon) {
            markerStr += `icon:${options.markerIcon}|`;
        }
        if (hasIcon && "markerAnchor" in options) {
            markerStr += `anchor:${options.markerAnchor}|`;
        }
        if (hasIcon && options.hiDPI) {
            markerStr += `scale:2|`;
        }
        const markerList = Array.isArray(options.markers[0]) ? options.markers : [
            options.markers
        ];
        markerStr += markerList.map((m)=>staticMapMarkerToString(m, !hasIcon)).join("|");
        endpoint.searchParams.set("markers", markerStr);
    }
    if ("path" in options) {
        let pathStr = "";
        pathStr += `fill:${options.pathFillColor ?? "none"}|`;
        if ("pathStrokeColor" in options) {
            pathStr += `stroke:${options.pathStrokeColor}|`;
        }
        if ("pathWidth" in options) {
            const pathWidth = options.pathWidth / (options.hiDPI ? 2 : 1);
            pathStr += `width:${pathWidth.toString()}|`;
        }
        pathStr += simplifyAndStringify(options.path);
        endpoint.searchParams.set("path", pathStr);
    }
    endpoint.searchParams.set("key", options.apiKey ?? config.apiKey);
    return endpoint.toString();
}
const staticMaps = {
    centered,
    bounded,
    automatic
};
const EARTH_RADIUS = 63710088e-1;
const EARTH_CIRCUMFERENCE = 2 * Math.PI * EARTH_RADIUS;
function longitudeToMercatorX(lng) {
    return (180 + lng) / 360;
}
function latitudeToMercatorY(lat) {
    return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360))) / 360;
}
function wgs84ToMercator(position) {
    const wrappedPos = wrapWgs84(position);
    return [
        longitudeToMercatorX(wrappedPos[0]),
        latitudeToMercatorY(wrappedPos[1])
    ];
}
function mercatorXToLongitude(x) {
    return x * 360 - 180;
}
function mercatorYToLatitude(y) {
    const y2 = 180 - y * 360;
    return 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;
}
function mercatorToWgs84(position) {
    return [
        mercatorXToLongitude(position[0]),
        mercatorYToLatitude(position[1])
    ];
}
function haversineDistanceWgs84(from, to) {
    const rad = Math.PI / 180;
    const lat1 = from[1] * rad;
    const lat2 = to[1] * rad;
    const a = Math.sin(lat1) * Math.sin(lat2) + Math.cos(lat1) * Math.cos(lat2) * Math.cos((to[0] - from[0]) * rad);
    const maxMeters = EARTH_RADIUS * Math.acos(Math.min(a, 1));
    return maxMeters;
}
function haversineCumulatedDistanceWgs84(positions) {
    const cumulatedDistance = Array(positions.length);
    cumulatedDistance[0] = 0;
    const l = cumulatedDistance.length;
    for(let i = 1; i < l; i++){
        cumulatedDistance[i] = haversineDistanceWgs84(positions[i - 1], positions[i]) + cumulatedDistance[i - 1];
    }
    return cumulatedDistance;
}
function wrapWgs84(position) {
    const lng = position[0];
    const lat = position[1];
    const d = 360;
    const w = ((lng + 180) % d + d) % d - 180;
    const wrapLong = w === -180 ? 180 : w;
    return [
        wrapLong,
        lat
    ];
}
function circumferenceAtLatitude(latitude) {
    return EARTH_CIRCUMFERENCE * Math.cos(latitude * Math.PI / 180);
}
function mercatorToTileIndex(position, zoom, strict = true) {
    const numberOfTilePerAxis = 2 ** zoom;
    const fIndex = [
        position[0] * numberOfTilePerAxis,
        position[1] * numberOfTilePerAxis
    ];
    return strict ? [
        ~~fIndex[0],
        ~~fIndex[1]
    ] : fIndex;
}
function wgs84ToTileIndex(position, zoom, strict = true) {
    const merc = wgs84ToMercator(position);
    return mercatorToTileIndex(merc, zoom, strict);
}
function toRadians(degrees) {
    return degrees * Math.PI / 180;
}
function toDegrees(radians) {
    return radians * 180 / Math.PI;
}
function haversineIntermediateWgs84(pos1, pos2, ratio) {
    const d = haversineDistanceWgs84(pos1, pos2);
    const 1 = toRadians(pos1[0]);
    const 1 = toRadians(pos1[1]);
    const 2 = toRadians(pos2[0]);
    const 2 = toRadians(pos2[1]);
    const  = d / EARTH_RADIUS;
    const a = Math.sin((1 - ratio) * ) / Math.sin();
    const b = Math.sin(ratio * ) / Math.sin();
    const x = a * Math.cos(1) * Math.cos(1) + b * Math.cos(2) * Math.cos(2);
    const y = a * Math.cos(1) * Math.sin(1) + b * Math.cos(2) * Math.sin(2);
    const z = a * Math.sin(1) + b * Math.sin(2);
    const 3 = Math.atan2(z, Math.sqrt(x * x + y * y));
    const 3 = Math.atan2(y, x);
    return [
        toDegrees(3),
        toDegrees(3)
    ];
}
const math = {
    EARTH_RADIUS,
    EARTH_CIRCUMFERENCE,
    longitudeToMercatorX,
    latitudeToMercatorY,
    wgs84ToMercator,
    mercatorXToLongitude,
    mercatorYToLatitude,
    mercatorToWgs84,
    haversineDistanceWgs84,
    wrapWgs84,
    circumferenceAtLatitude,
    mercatorToTileIndex,
    wgs84ToTileIndex,
    toRadians,
    toDegrees,
    haversineIntermediateWgs84,
    haversineCumulatedDistanceWgs84
};
let tileCache = null;
function getTileCache() {
    if (!tileCache) {
        tileCache = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$quick$2d$lru$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
            maxSize: config.tileCacheSize
        });
    }
    return tileCache;
}
async function bufferToPixelDataBrowser(buff) {
    const blob = new Blob([
        buff
    ]);
    const imageBitmap = await createImageBitmap(blob);
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    canvas.width = imageBitmap.width;
    canvas.height = imageBitmap.height;
    ctx.drawImage(imageBitmap, 0, 0);
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    return {
        pixels: imageData.data,
        width: canvas.width,
        height: canvas.height,
        components: imageData.data.length / (canvas.width * canvas.height)
    };
}
function getBufferToPixelDataParser() {
    if (config.bufferToPixelData) {
        return config.bufferToPixelData;
    }
    if (typeof window !== "undefined") {
        return bufferToPixelDataBrowser;
    }
    throw new Error("An image file buffer to pixel data parser is necessary. Specify it in `config.bufferToPixelData`");
}
const terrainTileJsonURL = "tiles/terrain-rgb-v2/tiles.json";
let terrainTileJson = null;
const customMessages = {
    403: "Key is missing, invalid or restricted"
};
async function fetchTerrainTileJson(apiKey) {
    const endpoint = new URL(terrainTileJsonURL, defaults.maptilerApiURL);
    endpoint.searchParams.set("key", apiKey);
    const urlWithParams = endpoint.toString();
    const res = await callFetch(urlWithParams);
    if (res.ok) {
        terrainTileJson = await res.json();
        return terrainTileJson;
    } else {
        if (!res.ok) {
            throw new ServiceError(res, customMessages[res.status] ?? "");
        }
    }
}
async function at(position, options = {}) {
    const apiKey = options.apiKey ?? config.apiKey;
    if (!terrainTileJson) {
        await fetchTerrainTileJson(apiKey);
    }
    const maxZoom = terrainTileJson.maxzoom;
    let zoom = ~~(options.zoom ?? maxZoom);
    if (zoom > maxZoom || zoom < 0) {
        zoom = maxZoom;
    }
    const tileIndex = math.wgs84ToTileIndex(position, zoom, false);
    const tileX = ~~tileIndex[0];
    const tileY = ~~tileIndex[1];
    if (!terrainTileJson.tiles.length) {
        throw new Error("Terrain tileJSON tile list is empty.");
    }
    const tileID = `terrain_${zoom.toString()}_${tileX.toString()}_${tileY.toString()}`;
    let tilePixelData;
    const cache = getTileCache();
    if (cache.has(tileID)) {
        tilePixelData = cache.get(tileID);
    } else {
        const tileURL = terrainTileJson.tiles[0].replace("{x}", tileX.toString()).replace("{y}", tileY.toString()).replace("{z}", zoom.toString());
        const tileRes = await callFetch(tileURL);
        if (!tileRes.ok) {
            throw new ServiceError(tileRes, customMessages[tileRes.status] ?? "");
        }
        const tileBuff = await tileRes.arrayBuffer();
        const tileParser = getBufferToPixelDataParser();
        tilePixelData = await tileParser(tileBuff);
        cache.set(tileID, tilePixelData);
    }
    const pixelX = ~~(tilePixelData.width * (tileIndex[0] % 1));
    const pixelY = ~~(tilePixelData.height * (tileIndex[1] % 1));
    const pixelDataIndex = (pixelY * tilePixelData.width + pixelX) * tilePixelData.components;
    const R = tilePixelData.pixels[pixelDataIndex];
    const G = tilePixelData.pixels[pixelDataIndex + 1];
    const B = tilePixelData.pixels[pixelDataIndex + 2];
    const elevation2 = -1e4 + (R * 256 * 256 + G * 256 + B) * 0.1;
    return [
        position[0],
        position[1],
        elevation2
    ];
}
async function batch(positions, options = {}) {
    const apiKey = options.apiKey ?? config.apiKey;
    if (!terrainTileJson) {
        await fetchTerrainTileJson(apiKey);
    }
    const tileParser = getBufferToPixelDataParser();
    const tileURLSchema = terrainTileJson.tiles[0];
    const cache = getTileCache();
    const maxZoom = terrainTileJson.maxzoom;
    let zoom = ~~(options.zoom ?? maxZoom);
    if (zoom > maxZoom || zoom < 0) {
        zoom = maxZoom;
    }
    const tileIndicesFloats = positions.map((position)=>math.wgs84ToTileIndex(position, zoom, false));
    const tileIndicesInteger = tileIndicesFloats.map((index)=>[
            ~~index[0],
            ~~index[1]
        ]);
    const tileIDs = tileIndicesInteger.map((index)=>`terrain_${zoom.toString()}_${index[0].toString()}_${index[1].toString()}`);
    const uniqueTilesToFetch = Array.from(new Set(tileIDs.filter((tileID)=>!cache.has(tileID)))).map((tileID)=>tileID.split("_").slice(1));
    const tileURLs = uniqueTilesToFetch.map((zxy)=>tileURLSchema.replace("{x}", zxy[1].toString()).replace("{y}", zxy[2].toString()).replace("{z}", zxy[0].toString()));
    const promisesFetchTiles = tileURLs.map((url)=>callFetch(url));
    const resTiles = await Promise.allSettled(promisesFetchTiles);
    const fulfilledRes = resTiles.map((el)=>el.status === "fulfilled" ? el.value : null).filter((res)=>res);
    const fulfilledRButNotOkRes = fulfilledRes.filter((res)=>!res.ok);
    if (fulfilledRes.length !== promisesFetchTiles.length) {
        throw new Error("Some tiles could not be fetched.");
    }
    if (fulfilledRButNotOkRes.length) {
        throw new ServiceError(fulfilledRButNotOkRes[0], customMessages[fulfilledRButNotOkRes[0].status] ?? "");
    }
    const tileArrayBuffers = await Promise.all(fulfilledRes.map((res)=>res.arrayBuffer()));
    if (!tileArrayBuffers.every((buff)=>buff.byteLength > 0)) {
        throw new Error("Some tiles are not available.");
    }
    const tilePixelDatas = await Promise.all(tileArrayBuffers.map((buff)=>tileParser(buff)));
    tilePixelDatas.forEach((tilePixelData, i)=>{
        const zxy = uniqueTilesToFetch[i];
        const tileID = `terrain_${zxy[0].toString()}_${zxy[1].toString()}_${zxy[2].toString()}`;
        cache.set(tileID, tilePixelData);
    });
    const elevatedPositions = positions.map((position, i)=>{
        const tileID = tileIDs[i];
        const tileIndexFloat = tileIndicesFloats[i];
        const tilePixelData = cache.get(tileID);
        const pixelX = Math.min(Math.round(tilePixelData.width * (tileIndexFloat[0] % 1)), tilePixelData.width - 1);
        const pixelY = Math.min(Math.round(tilePixelData.height * (tileIndexFloat[1] % 1)), tilePixelData.height - 1);
        const pixelDataIndex = (pixelY * tilePixelData.width + pixelX) * tilePixelData.components;
        const R = tilePixelData.pixels[pixelDataIndex];
        const G = tilePixelData.pixels[pixelDataIndex + 1];
        const B = tilePixelData.pixels[pixelDataIndex + 2];
        const elevation2 = -1e4 + (R * 256 * 256 + G * 256 + B) * 0.1;
        return [
            position[0],
            position[1],
            ~~(elevation2 * 1e3) / 1e3
        ];
    });
    if (options.smoothingKernelSize) {
        const kernelSize = ~~(options.smoothingKernelSize / 2) * 2 + 1;
        const elevations = elevatedPositions.map((pos)=>pos[2]);
        const kernelSpan = ~~(kernelSize / 2);
        for(let i = kernelSpan; i < elevations.length - kernelSpan - 1; i += 1){
            let sum = 0;
            for(let j = 0; j < kernelSize; j += 1){
                const elev = elevations[i - kernelSpan + j];
                sum += elev;
            }
            sum /= kernelSize;
            elevatedPositions[i][2] = sum;
        }
    }
    return elevatedPositions;
}
async function fromLineString(ls, options = {}) {
    if (ls.type !== "LineString") {
        throw new Error("The provided object is not a GeoJSON LineString");
    }
    const clone = structuredClone(ls);
    const elevatedPositions = await batch(clone.coordinates, options);
    clone.coordinates = elevatedPositions;
    return clone;
}
async function fromMultiLineString(ls, options = {}) {
    if (ls.type !== "MultiLineString") {
        throw new Error("The provided object is not a GeoJSON MultiLineString");
    }
    const clone = structuredClone(ls);
    const multiLengths = clone.coordinates.map((poss)=>poss.length);
    const flattenPositions = clone.coordinates.flat();
    const flattenPositionsElevated = await batch(flattenPositions, options);
    const result = [];
    let index = 0;
    for (const length of multiLengths){
        result.push(flattenPositionsElevated.slice(index, index + length));
        index += length;
    }
    clone.coordinates = result;
    return clone;
}
const elevation = {
    at,
    batch,
    fromLineString,
    fromMultiLineString
};
;
 //# sourceMappingURL=maptiler-client.mjs.map
}}),
"[project]/node_modules/events/events.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';
var R = typeof Reflect === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;
if (R && typeof R.ownKeys === 'function') {
    ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
    ReflectOwnKeys = function ReflectOwnKeys(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
    };
} else {
    ReflectOwnKeys = function ReflectOwnKeys(target) {
        return Object.getOwnPropertyNames(target);
    };
}
function ProcessEmitWarning(warning) {
    if (console && console.warn) console.warn(warning);
}
var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
    return value !== value;
};
function EventEmitter() {
    EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;
// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;
// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;
function checkListener(listener) {
    if (typeof listener !== 'function') {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
    }
}
Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
    enumerable: true,
    get: function() {
        return defaultMaxListeners;
    },
    set: function(arg) {
        if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
        }
        defaultMaxListeners = arg;
    }
});
EventEmitter.init = function() {
    if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
        this._events = Object.create(null);
        this._eventsCount = 0;
    }
    this._maxListeners = this._maxListeners || undefined;
};
// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
    }
    this._maxListeners = n;
    return this;
};
function _getMaxListeners(that) {
    if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
    return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit(type) {
    var args = [];
    for(var i = 1; i < arguments.length; i++)args.push(arguments[i]);
    var doError = type === 'error';
    var events = this._events;
    if (events !== undefined) doError = doError && events.error === undefined;
    else if (!doError) return false;
    // If there is no 'error' event listener then throw.
    if (doError) {
        var er;
        if (args.length > 0) er = args[0];
        if (er instanceof Error) {
            // Note: The comments on the `throw` lines are intentional, they show
            // up in Node's output if this results in an unhandled exception.
            throw er; // Unhandled 'error' event
        }
        // At least give some kind of context to the user
        var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
        err.context = er;
        throw err; // Unhandled 'error' event
    }
    var handler = events[type];
    if (handler === undefined) return false;
    if (typeof handler === 'function') {
        ReflectApply(handler, this, args);
    } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for(var i = 0; i < len; ++i)ReflectApply(listeners[i], this, args);
    }
    return true;
};
function _addListener(target, type, listener, prepend) {
    var m;
    var events;
    var existing;
    checkListener(listener);
    events = target._events;
    if (events === undefined) {
        events = target._events = Object.create(null);
        target._eventsCount = 0;
    } else {
        // To avoid recursion in the case that type === "newListener"! Before
        // adding it to the listeners, first emit "newListener".
        if (events.newListener !== undefined) {
            target.emit('newListener', type, listener.listener ? listener.listener : listener);
            // Re-assign `events` because a newListener handler could have caused the
            // this._events to be assigned to a new object
            events = target._events;
        }
        existing = events[type];
    }
    if (existing === undefined) {
        // Optimize the case of one listener. Don't need the extra array object.
        existing = events[type] = listener;
        ++target._eventsCount;
    } else {
        if (typeof existing === 'function') {
            // Adding the second element, need to change to array.
            existing = events[type] = prepend ? [
                listener,
                existing
            ] : [
                existing,
                listener
            ];
        // If we've already got an array, just append.
        } else if (prepend) {
            existing.unshift(listener);
        } else {
            existing.push(listener);
        }
        // Check for listener leak
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
            existing.warned = true;
            // No error code for this since it is a Warning
            // eslint-disable-next-line no-restricted-syntax
            var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
            w.name = 'MaxListenersExceededWarning';
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            ProcessEmitWarning(w);
        }
    }
    return target;
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
    return _addListener(this, type, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type, listener) {
    return _addListener(this, type, listener, true);
};
function onceWrapper() {
    if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0) return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
    }
}
function _onceWrap(target, type, listener) {
    var state = {
        fired: false,
        wrapFn: undefined,
        target: target,
        type: type,
        listener: listener
    };
    var wrapped = onceWrapper.bind(state);
    wrapped.listener = listener;
    state.wrapFn = wrapped;
    return wrapped;
}
EventEmitter.prototype.once = function once(type, listener) {
    checkListener(listener);
    this.on(type, _onceWrap(this, type, listener));
    return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
    checkListener(listener);
    this.prependListener(type, _onceWrap(this, type, listener));
    return this;
};
// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener = function removeListener(type, listener) {
    var list, events, position, i, originalListener;
    checkListener(listener);
    events = this._events;
    if (events === undefined) return this;
    list = events[type];
    if (list === undefined) return this;
    if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0) this._events = Object.create(null);
        else {
            delete events[type];
            if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
        }
    } else if (typeof list !== 'function') {
        position = -1;
        for(i = list.length - 1; i >= 0; i--){
            if (list[i] === listener || list[i].listener === listener) {
                originalListener = list[i].listener;
                position = i;
                break;
            }
        }
        if (position < 0) return this;
        if (position === 0) list.shift();
        else {
            spliceOne(list, position);
        }
        if (list.length === 1) events[type] = list[0];
        if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
    }
    return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
    var listeners, events, i;
    events = this._events;
    if (events === undefined) return this;
    // not listening for removeListener, no need to emit
    if (events.removeListener === undefined) {
        if (arguments.length === 0) {
            this._events = Object.create(null);
            this._eventsCount = 0;
        } else if (events[type] !== undefined) {
            if (--this._eventsCount === 0) this._events = Object.create(null);
            else delete events[type];
        }
        return this;
    }
    // emit removeListener for all listeners on all events
    if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for(i = 0; i < keys.length; ++i){
            key = keys[i];
            if (key === 'removeListener') continue;
            this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
    }
    listeners = events[type];
    if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
    } else if (listeners !== undefined) {
        // LIFO order
        for(i = listeners.length - 1; i >= 0; i--){
            this.removeListener(type, listeners[i]);
        }
    }
    return this;
};
function _listeners(target, type, unwrap) {
    var events = target._events;
    if (events === undefined) return [];
    var evlistener = events[type];
    if (evlistener === undefined) return [];
    if (typeof evlistener === 'function') return unwrap ? [
        evlistener.listener || evlistener
    ] : [
        evlistener
    ];
    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}
EventEmitter.prototype.listeners = function listeners(type) {
    return _listeners(this, type, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type) {
    return _listeners(this, type, false);
};
EventEmitter.listenerCount = function(emitter, type) {
    if (typeof emitter.listenerCount === 'function') {
        return emitter.listenerCount(type);
    } else {
        return listenerCount.call(emitter, type);
    }
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
    var events = this._events;
    if (events !== undefined) {
        var evlistener = events[type];
        if (typeof evlistener === 'function') {
            return 1;
        } else if (evlistener !== undefined) {
            return evlistener.length;
        }
    }
    return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(arr, n) {
    var copy = new Array(n);
    for(var i = 0; i < n; ++i)copy[i] = arr[i];
    return copy;
}
function spliceOne(list, index) {
    for(; index + 1 < list.length; index++)list[index] = list[index + 1];
    list.pop();
}
function unwrapListeners(arr) {
    var ret = new Array(arr.length);
    for(var i = 0; i < ret.length; ++i){
        ret[i] = arr[i].listener || arr[i];
    }
    return ret;
}
function once(emitter, name) {
    return new Promise(function(resolve, reject) {
        function errorListener(err) {
            emitter.removeListener(name, resolver);
            reject(err);
        }
        function resolver() {
            if (typeof emitter.removeListener === 'function') {
                emitter.removeListener('error', errorListener);
            }
            resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name, resolver, {
            once: true
        });
        if (name !== 'error') {
            addErrorHandlerIfEventEmitter(emitter, errorListener, {
                once: true
            });
        }
    });
}
function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
    if (typeof emitter.on === 'function') {
        eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
    }
}
function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
    if (typeof emitter.on === 'function') {
        if (flags.once) {
            emitter.once(name, listener);
        } else {
            emitter.on(name, listener);
        }
    } else if (typeof emitter.addEventListener === 'function') {
        // EventTarget does not have `error` event semantics like Node
        // EventEmitters, we do not listen for `error` events here.
        emitter.addEventListener(name, function wrapListener(arg) {
            // IE does not have builtin `{ once: true }` support so we
            // have to do it manually.
            if (flags.once) {
                emitter.removeEventListener(name, wrapListener);
            }
            listener(arg);
        });
    } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
    }
}
}}),
"[project]/node_modules/uuid/dist/esm-browser/native.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const __TURBOPACK__default__export__ = {
    randomUUID
};
}}),
"[project]/node_modules/uuid/dist/esm-browser/rng.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>rng)
});
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
    if (!getRandomValues) {
        if (typeof crypto === 'undefined' || !crypto.getRandomValues) {
            throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
        }
        getRandomValues = crypto.getRandomValues.bind(crypto);
    }
    return getRandomValues(rnds8);
}
}}),
"[project]/node_modules/uuid/dist/esm-browser/regex.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
}}),
"[project]/node_modules/uuid/dist/esm-browser/validate.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$regex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-browser/regex.js [app-client] (ecmascript)");
;
function validate(uuid) {
    return typeof uuid === 'string' && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$regex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].test(uuid);
}
const __TURBOPACK__default__export__ = validate;
}}),
"[project]/node_modules/uuid/dist/esm-browser/stringify.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__),
    "unsafeStringify": (()=>unsafeStringify)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$validate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-browser/validate.js [app-client] (ecmascript)");
;
const byteToHex = [];
for(let i = 0; i < 256; ++i){
    byteToHex.push((i + 0x100).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
    return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
function stringify(arr, offset = 0) {
    const uuid = unsafeStringify(arr, offset);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$validate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(uuid)) {
        throw TypeError('Stringified UUID is invalid');
    }
    return uuid;
}
const __TURBOPACK__default__export__ = stringify;
}}),
"[project]/node_modules/uuid/dist/esm-browser/v4.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$native$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-browser/native.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$rng$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-browser/rng.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$stringify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-browser/stringify.js [app-client] (ecmascript)");
;
;
;
function v4(options, buf, offset) {
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$native$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].randomUUID && !buf && !options) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$native$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].randomUUID();
    }
    options = options || {};
    const rnds = options.random ?? options.rng?.() ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$rng$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])();
    if (rnds.length < 16) {
        throw new Error('Random bytes length must be >= 16');
    }
    rnds[6] = rnds[6] & 0x0f | 0x40;
    rnds[8] = rnds[8] & 0x3f | 0x80;
    if (buf) {
        offset = offset || 0;
        if (offset < 0 || offset + 16 > buf.length) {
            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
        }
        for(let i = 0; i < 16; ++i){
            buf[offset + i] = rnds[i];
        }
        return buf;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$stringify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unsafeStringify"])(rnds);
}
const __TURBOPACK__default__export__ = v4;
}}),
"[project]/node_modules/uuid/dist/esm-browser/v4.js [app-client] (ecmascript) <export default as v4>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "v4": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$v4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$v4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-browser/v4.js [app-client] (ecmascript)");
}}),
"[project]/node_modules/js-base64/base64.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 *  base64.ts
 *
 *  Licensed under the BSD 3-Clause License.
 *    http://opensource.org/licenses/BSD-3-Clause
 *
 *  References:
 *    http://en.wikipedia.org/wiki/Base64
 *
 * @author Dan Kogai (https://github.com/dankogai)
 */ __turbopack_context__.s({
    "Base64": (()=>gBase64),
    "VERSION": (()=>VERSION),
    "atob": (()=>_atob),
    "atobPolyfill": (()=>atobPolyfill),
    "btoa": (()=>_btoa),
    "btoaPolyfill": (()=>btoaPolyfill),
    "btou": (()=>btou),
    "decode": (()=>decode),
    "encode": (()=>encode),
    "encodeURI": (()=>encodeURI),
    "encodeURL": (()=>encodeURI),
    "extendBuiltins": (()=>extendBuiltins),
    "extendString": (()=>extendString),
    "extendUint8Array": (()=>extendUint8Array),
    "fromBase64": (()=>decode),
    "fromUint8Array": (()=>fromUint8Array),
    "isValid": (()=>isValid),
    "toBase64": (()=>encode),
    "toUint8Array": (()=>toUint8Array),
    "utob": (()=>utob),
    "version": (()=>version)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
const version = '3.7.7';
/**
 * @deprecated use lowercase `version`.
 */ const VERSION = version;
const _hasBuffer = typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"] === 'function';
const _TD = typeof TextDecoder === 'function' ? new TextDecoder() : undefined;
const _TE = typeof TextEncoder === 'function' ? new TextEncoder() : undefined;
const b64ch = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
const b64chs = Array.prototype.slice.call(b64ch);
const b64tab = ((a)=>{
    let tab = {};
    a.forEach((c, i)=>tab[c] = i);
    return tab;
})(b64chs);
const b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
const _fromCC = String.fromCharCode.bind(String);
const _U8Afrom = typeof Uint8Array.from === 'function' ? Uint8Array.from.bind(Uint8Array) : (it)=>new Uint8Array(Array.prototype.slice.call(it, 0));
const _mkUriSafe = (src)=>src.replace(/=/g, '').replace(/[+\/]/g, (m0)=>m0 == '+' ? '-' : '_');
const _tidyB64 = (s)=>s.replace(/[^A-Za-z0-9\+\/]/g, '');
/**
 * polyfill version of `btoa`
 */ const btoaPolyfill = (bin)=>{
    // console.log('polyfilled');
    let u32, c0, c1, c2, asc = '';
    const pad = bin.length % 3;
    for(let i = 0; i < bin.length;){
        if ((c0 = bin.charCodeAt(i++)) > 255 || (c1 = bin.charCodeAt(i++)) > 255 || (c2 = bin.charCodeAt(i++)) > 255) throw new TypeError('invalid character found');
        u32 = c0 << 16 | c1 << 8 | c2;
        asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];
    }
    return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
};
/**
 * does what `window.btoa` of web browsers do.
 * @param {String} bin binary string
 * @returns {string} Base64-encoded string
 */ const _btoa = typeof btoa === 'function' ? (bin)=>btoa(bin) : _hasBuffer ? (bin)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(bin, 'binary').toString('base64') : btoaPolyfill;
const _fromUint8Array = _hasBuffer ? (u8a)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(u8a).toString('base64') : (u8a)=>{
    // cf. https://stackoverflow.com/questions/12710001/how-to-convert-uint8-array-to-base64-encoded-string/12713326#12713326
    const maxargs = 0x1000;
    let strs = [];
    for(let i = 0, l = u8a.length; i < l; i += maxargs){
        strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));
    }
    return _btoa(strs.join(''));
};
/**
 * converts a Uint8Array to a Base64 string.
 * @param {boolean} [urlsafe] URL-and-filename-safe a la RFC4648 5
 * @returns {string} Base64 string
 */ const fromUint8Array = (u8a, urlsafe = false)=>urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
// This trick is found broken https://github.com/dankogai/js-base64/issues/130
// const utob = (src: string) => unescape(encodeURIComponent(src));
// reverting good old fationed regexp
const cb_utob = (c)=>{
    if (c.length < 2) {
        var cc = c.charCodeAt(0);
        return cc < 0x80 ? c : cc < 0x800 ? _fromCC(0xc0 | cc >>> 6) + _fromCC(0x80 | cc & 0x3f) : _fromCC(0xe0 | cc >>> 12 & 0x0f) + _fromCC(0x80 | cc >>> 6 & 0x3f) + _fromCC(0x80 | cc & 0x3f);
    } else {
        var cc = 0x10000 + (c.charCodeAt(0) - 0xD800) * 0x400 + (c.charCodeAt(1) - 0xDC00);
        return _fromCC(0xf0 | cc >>> 18 & 0x07) + _fromCC(0x80 | cc >>> 12 & 0x3f) + _fromCC(0x80 | cc >>> 6 & 0x3f) + _fromCC(0x80 | cc & 0x3f);
    }
};
const re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
/**
 * @deprecated should have been internal use only.
 * @param {string} src UTF-8 string
 * @returns {string} UTF-16 string
 */ const utob = (u)=>u.replace(re_utob, cb_utob);
//
const _encode = _hasBuffer ? (s)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(s, 'utf8').toString('base64') : _TE ? (s)=>_fromUint8Array(_TE.encode(s)) : (s)=>_btoa(utob(s));
/**
 * converts a UTF-8-encoded string to a Base64 string.
 * @param {boolean} [urlsafe] if `true` make the result URL-safe
 * @returns {string} Base64 string
 */ const encode = (src, urlsafe = false)=>urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);
/**
 * converts a UTF-8-encoded string to URL-safe Base64 RFC4648 5.
 * @returns {string} Base64 string
 */ const encodeURI = (src)=>encode(src, true);
// This trick is found broken https://github.com/dankogai/js-base64/issues/130
// const btou = (src: string) => decodeURIComponent(escape(src));
// reverting good old fationed regexp
const re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
const cb_btou = (cccc)=>{
    switch(cccc.length){
        case 4:
            var cp = (0x07 & cccc.charCodeAt(0)) << 18 | (0x3f & cccc.charCodeAt(1)) << 12 | (0x3f & cccc.charCodeAt(2)) << 6 | 0x3f & cccc.charCodeAt(3), offset = cp - 0x10000;
            return _fromCC((offset >>> 10) + 0xD800) + _fromCC((offset & 0x3FF) + 0xDC00);
        case 3:
            return _fromCC((0x0f & cccc.charCodeAt(0)) << 12 | (0x3f & cccc.charCodeAt(1)) << 6 | 0x3f & cccc.charCodeAt(2));
        default:
            return _fromCC((0x1f & cccc.charCodeAt(0)) << 6 | 0x3f & cccc.charCodeAt(1));
    }
};
/**
 * @deprecated should have been internal use only.
 * @param {string} src UTF-16 string
 * @returns {string} UTF-8 string
 */ const btou = (b)=>b.replace(re_btou, cb_btou);
/**
 * polyfill version of `atob`
 */ const atobPolyfill = (asc)=>{
    // console.log('polyfilled');
    asc = asc.replace(/\s+/g, '');
    if (!b64re.test(asc)) throw new TypeError('malformed base64.');
    asc += '=='.slice(2 - (asc.length & 3));
    let u24, bin = '', r1, r2;
    for(let i = 0; i < asc.length;){
        u24 = b64tab[asc.charAt(i++)] << 18 | b64tab[asc.charAt(i++)] << 12 | (r1 = b64tab[asc.charAt(i++)]) << 6 | (r2 = b64tab[asc.charAt(i++)]);
        bin += r1 === 64 ? _fromCC(u24 >> 16 & 255) : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255) : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
    }
    return bin;
};
/**
 * does what `window.atob` of web browsers do.
 * @param {String} asc Base64-encoded string
 * @returns {string} binary string
 */ const _atob = typeof atob === 'function' ? (asc)=>atob(_tidyB64(asc)) : _hasBuffer ? (asc)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(asc, 'base64').toString('binary') : atobPolyfill;
//
const _toUint8Array = _hasBuffer ? (a)=>_U8Afrom(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(a, 'base64')) : (a)=>_U8Afrom(_atob(a).split('').map((c)=>c.charCodeAt(0)));
/**
 * converts a Base64 string to a Uint8Array.
 */ const toUint8Array = (a)=>_toUint8Array(_unURI(a));
//
const _decode = _hasBuffer ? (a)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(a, 'base64').toString('utf8') : _TD ? (a)=>_TD.decode(_toUint8Array(a)) : (a)=>btou(_atob(a));
const _unURI = (a)=>_tidyB64(a.replace(/[-_]/g, (m0)=>m0 == '-' ? '+' : '/'));
/**
 * converts a Base64 string to a UTF-8 string.
 * @param {String} src Base64 string.  Both normal and URL-safe are supported
 * @returns {string} UTF-8 string
 */ const decode = (src)=>_decode(_unURI(src));
/**
 * check if a value is a valid Base64 string
 * @param {String} src a value to check
  */ const isValid = (src)=>{
    if (typeof src !== 'string') return false;
    const s = src.replace(/\s+/g, '').replace(/={0,2}$/, '');
    return !/[^\s0-9a-zA-Z\+/]/.test(s) || !/[^\s0-9a-zA-Z\-_]/.test(s);
};
//
const _noEnum = (v)=>{
    return {
        value: v,
        enumerable: false,
        writable: true,
        configurable: true
    };
};
/**
 * extend String.prototype with relevant methods
 */ const extendString = function() {
    const _add = (name, body)=>Object.defineProperty(String.prototype, name, _noEnum(body));
    _add('fromBase64', function() {
        return decode(this);
    });
    _add('toBase64', function(urlsafe) {
        return encode(this, urlsafe);
    });
    _add('toBase64URI', function() {
        return encode(this, true);
    });
    _add('toBase64URL', function() {
        return encode(this, true);
    });
    _add('toUint8Array', function() {
        return toUint8Array(this);
    });
};
/**
 * extend Uint8Array.prototype with relevant methods
 */ const extendUint8Array = function() {
    const _add = (name, body)=>Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));
    _add('toBase64', function(urlsafe) {
        return fromUint8Array(this, urlsafe);
    });
    _add('toBase64URI', function() {
        return fromUint8Array(this, true);
    });
    _add('toBase64URL', function() {
        return fromUint8Array(this, true);
    });
};
/**
 * extend Builtin prototypes with relevant methods
 */ const extendBuiltins = ()=>{
    extendString();
    extendUint8Array();
};
const gBase64 = {
    version: version,
    VERSION: VERSION,
    atob: _atob,
    atobPolyfill: atobPolyfill,
    btoa: _btoa,
    btoaPolyfill: btoaPolyfill,
    fromBase64: decode,
    toBase64: encode,
    encode: encode,
    encodeURI: encodeURI,
    encodeURL: encodeURI,
    utob: utob,
    btou: btou,
    decode: decode,
    isValid: isValid,
    fromUint8Array: fromUint8Array,
    toUint8Array: toUint8Array,
    extendString: extendString,
    extendUint8Array: extendUint8Array,
    extendBuiltins: extendBuiltins
};
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
}}),
}]);

//# sourceMappingURL=node_modules_9aa2a1df._.js.map